

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>svvamp.rules.rule &mdash; SVVAMP 0.6.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SVVAMP
          

          
          </a>

          
            
            
              <div class="version">
                0.6.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">SVVAMP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SVVAMP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>svvamp.rules.rule</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for svvamp.rules.rule</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on 29 nov. 2018, 10:38</span>
<span class="sd">Copyright Fran√ßois Durand 2014-2018</span>
<span class="sd">fradurand@gmail.com</span>

<span class="sd">This file is part of SVVAMP.</span>

<span class="sd">    SVVAMP is free software: you can redistribute it and/or modify</span>
<span class="sd">    it under the terms of the GNU General Public License as published by</span>
<span class="sd">    the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">    (at your option) any later version.</span>

<span class="sd">    SVVAMP is distributed in the hope that it will be useful,</span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">    GNU General Public License for more details.</span>

<span class="sd">    You should have received a copy of the GNU General Public License</span>
<span class="sd">    along with SVVAMP.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">svvamp.utils.constants</span> <span class="kn">import</span> <span class="n">OPTIONS</span>
<span class="kn">from</span> <span class="nn">svvamp.utils.util_cache</span> <span class="kn">import</span> <span class="n">cached_property</span><span class="p">,</span> <span class="n">DeleteCacheMixin</span>
<span class="kn">from</span> <span class="nn">svvamp.utils</span> <span class="kn">import</span> <span class="n">my_log</span><span class="p">,</span> <span class="n">type_checker</span>
<span class="kn">from</span> <span class="nn">svvamp.utils.printing</span> <span class="kn">import</span> <span class="n">printm</span><span class="p">,</span> <span class="n">print_title</span><span class="p">,</span> <span class="n">print_big_title</span>
<span class="kn">from</span> <span class="nn">svvamp.utils.misc</span> <span class="kn">import</span> <span class="n">compute_next_subset_with_w</span><span class="p">,</span> <span class="n">compute_next_borda_clever</span>
<span class="kn">from</span> <span class="nn">svvamp.utils.pseudo_bool</span> <span class="kn">import</span> <span class="n">pseudo_bool</span><span class="p">,</span> <span class="n">neginf_to_nan</span><span class="p">,</span> <span class="n">neginf_to_zero</span><span class="p">,</span> <span class="n">equal_true</span><span class="p">,</span> <span class="n">equal_false</span><span class="p">,</span> \
    <span class="n">pseudo_bool_not</span>
<span class="kn">from</span> <span class="nn">svvamp.preferences.profile</span> <span class="kn">import</span> <span class="n">Profile</span>
<span class="kn">from</span> <span class="nn">svvamp.preferences.profile_subset_candidates</span> <span class="kn">import</span> <span class="n">ProfileSubsetCandidates</span>


<div class="viewcode-block" id="Rule"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule">[docs]</a><span class="k">class</span> <span class="nc">Rule</span><span class="p">(</span><span class="n">DeleteCacheMixin</span><span class="p">,</span> <span class="n">my_log</span><span class="o">.</span><span class="n">MyLog</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A voting rule.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    options_parameters : dict</span>
<span class="sd">        It is a dictionary of allowed and default options. Allowed is a minimal check that will</span>
<span class="sd">        be performed before launching big simulations, but other checks might be performed when setting the option.</span>
<span class="sd">        Allowed is either a list of values, like [&#39;lazy&#39;, &#39;fast&#39;, &#39;exact&#39;], or a function checking if the parameter</span>
<span class="sd">        is correct. Example: ``{&#39;max_grade&#39;: dict(allowed=np.isfinite, default=1), &#39;option_example&#39;: dict(allowed=[42,</span>
<span class="sd">        51], default=42)}``.</span>
<span class="sd">    kwargs</span>
<span class="sd">        Additional keyword parameters. See :attr:`options_parameters` for allowed and default options.</span>
<span class="sd">    with_two_candidates_reduces_to_plurality : bool</span>
<span class="sd">        ``True`` iff, when using this voting system with only two candidates, it amounts to Plurality (with voter and</span>
<span class="sd">        candidate tie-breaking).</span>
<span class="sd">    is_based_on_rk : bool</span>
<span class="sd">        ``True`` iff this voting system is based only on strict rankings (no cardinal information, indifference not</span>
<span class="sd">        allowed).</span>
<span class="sd">    is_based_on_ut_minus1_1 : bool</span>
<span class="sd">        ``True`` iff:</span>

<span class="sd">            *   This voting system is based only on utilities (not rankings, i.e. does not depend on how voters break</span>
<span class="sd">                ties in their own preferences),</span>
<span class="sd">            *   And for a ``c``-manipulator (IM or CM), it is optimal to pretend that ``c`` has utility 1 and other</span>
<span class="sd">                candidates have utility -1.</span>
<span class="sd">    meets_iia : bool</span>
<span class="sd">        ``True`` iff this voting system meets Independence of Irrelevant Alternatives.</span>
<span class="sd">    precheck_um : bool</span>
<span class="sd">        If ``True``, then before computing CM, we check whether there is UM.</span>
<span class="sd">    precheck_tm : bool</span>
<span class="sd">        If ``True``, then before computing CM, we check whether there is TM.</span>
<span class="sd">    precheck_icm : bool</span>
<span class="sd">        If ``True``, then before computing CM, we check whether there is ICM. Remark: when the voting system meets</span>
<span class="sd">        InfMC_c_ctb, then precheck on ICM will not do better than other basic prechecks.</span>
<span class="sd">    log_identity : str</span>
<span class="sd">        Cf. :class:`MyLog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is an &#39;abstract&#39; class. As an end-user, you should always use its subclasses :attr:`~svvamp.Approval`,</span>
<span class="sd">    :attr:`~svvamp.Plurality`, etc.</span>

<span class="sd">    This class and its subclasses are suitable for voting rules that are deterministic and anonymous (treating all</span>
<span class="sd">    voters equally). As a consequence, they are not neutral (because they need to break ties in totally symmetric</span>
<span class="sd">    situations). As of now, SVVAMP does not support other kinds of voting systems.</span>

<span class="sd">    **Ties in a voter&#39;s utilities**</span>

<span class="sd">    When a sincere voter ``v`` must provide a strict order in a specific voting system, she uses</span>
<span class="sd">    :attr:`~svvamp.Profile.preferences_rk`\ ``[v, :]`` (which breaks possible ties in her utilities).</span>

<span class="sd">    In contrast, to know if a voter ``v`` wants to manipulate for a candidate ``c`` against ``w``, we always use her</span>
<span class="sd">    utilities :attr:`~svvamp.Profile.preferences_ut`\ ``[v, :]``. If she attributes the same utility to ``w`` and</span>
<span class="sd">    ``c``, she is not interested in this manipulation.</span>

<span class="sd">    Some ordinal voting systems in SVVAMP may be adapted to accept weak orders of preferences as ballots. This is</span>
<span class="sd">    future work.</span>

<span class="sd">    **Ties in the result of an election**</span>

<span class="sd">    The voting system itself may need to break ties, for example if candidates ``c`` and ``d`` have the same score in</span>
<span class="sd">    a score-based system. The standard tie-breaking in SVVAMP, referred to as Candidate Tie-Breaking (CTB),</span>
<span class="sd">    consists of breaking ties by lowest index: ``c`` is favored over ``d`` if ``c`` &lt; ``d``. This tie-breaking rule</span>
<span class="sd">    is used for example in &#39;A note on manipulability of large voting schemes&#39; (Peleg, 1979). Future voting rules</span>
<span class="sd">    implemented as a subclass of ``Rule`` may use another tie-breaking rule.</span>

<span class="sd">    **Options for manipulation**</span>

<span class="sd">    Attributes allow to choose the algorithm used to compute different kinds of manipulation:</span>
<span class="sd">    :attr:`~cm_option`, :attr:`~icm_option`, :attr:`~im_option`, :attr:`~tm_option` and :attr:`~um_option`.</span>

<span class="sd">    To know what options are accepted for a given voting system, use :attr:`~svvamp.Rule.options_parameters`. Here</span>
<span class="sd">    is a non-exhaustive list of typical values for these options.</span>

<span class="sd">            *   ``&#39;exact&#39;``: Exact algorithm. Can always decide manipulation: it answers ``True`` or ``False``. Other</span>
<span class="sd">                algorithms may also answer ``numpy.nan``, which is the SVVAMP convention meaning that the algorithm was</span>
<span class="sd">                not able to decide. For a given voting system, if the exact algorithm runs in polynomial time,</span>
<span class="sd">                then it is the only accepted option.</span>
<span class="sd">            *   ``&#39;slow&#39;``: Non-polynomial algorithm, but not exact. For voting systems accepting this option,</span>
<span class="sd">                it is however faster than &#39;exact&#39; (in a little-o sense) and more precise than &#39;fast&#39;.</span>
<span class="sd">            *   ``&#39;fast&#39;``: Polynomial algorithm, not exact. If the exact algorithm runs in polynomial time,</span>
<span class="sd">                this option is not available.</span>
<span class="sd">            *   ``&#39;lazy&#39;``: Perform only some preliminary checks. Run in polynomial time (unless deciding the winner</span>
<span class="sd">                of the election is not polynomial, like for :class:`~svvamp.Kemeny`). Like other non-exact</span>
<span class="sd">                algorithms, it can decide manipulation to ``True``, ``False`` or return ``numpy.nan`` (undecided).</span>

<span class="sd">    For a given voting system, the default option is the most precise algorithm running in polynomial time.</span>

<span class="sd">    **Option for Independence of Irrelevant Alternatives (IIA)**</span>

<span class="sd">    The default algorithm for :attr:`~svvamp.Rule.not_iia` first performs some preliminary checks based on the</span>
<span class="sd">    known properties of the voting system under study. For example, if it meets the Condorcet criterion,</span>
<span class="sd">    then the algorithm exploits if. If it meets the majority favorite criterion (see below) and if</span>
<span class="sd">    :attr:`w_` is a majority favorite, then it decides IIA immediately.</span>

<span class="sd">    If the preliminary checks do not allow to decide, the default algorithm then uses brute force to test subsets of</span>
<span class="sd">    candidates including the sincere winner :attr:`w_`. This can be non-polynomial or</span>
<span class="sd">    non-exact, depending on the attribute :attr:`iia_subset_maximum_size`.</span>

<span class="sd">    **Implication diagram between criteria**</span>

<span class="sd">    Cf. corresponding attributes below for the definition of these criteria. See Durand et al.,</span>
<span class="sd">    &#39;Condorcet Criterion and Reduction in Coalitional Manipulability&#39;.</span>

<span class="sd">    ::</span>

<span class="sd">        Condorcet_c_ut_rel_ctb            ==&gt;            Condorcet_c_ut_rel</span>
<span class="sd">        ||             Condorcet_c_rk_ctb ==&gt;      Condorcet_c_rk       ||</span>
<span class="sd">        ||           ||        ||                   ||         ||       ||</span>
<span class="sd">        V            V         ||                   ||         V        V</span>
<span class="sd">        Condorcet_c_ut_abs_ctb            ==&gt;            Condorcet_c_ut_abs</span>
<span class="sd">        ||                     ||                   ||                  ||</span>
<span class="sd">        ||                     V                    V                   ||</span>
<span class="sd">        ||     majority_favorite_c_rk_ctb ==&gt; majority_favorite_c_rk    ||</span>
<span class="sd">        ||            ||                                  ||            ||</span>
<span class="sd">        V             V                                   V             V</span>
<span class="sd">        majority_favorite_c_ut_ctb        ==&gt;        majority_favorite_ut_c</span>
<span class="sd">        ||                                                              ||</span>
<span class="sd">        V                                                               V</span>
<span class="sd">        IgnMC_c_ctb                       ==&gt;                       IgnMC_c</span>
<span class="sd">        ||                                                              ||</span>
<span class="sd">        V                                                               V</span>
<span class="sd">        InfMC_c_ctb                       ==&gt;                       InfMC_c</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Notes for developers:</span>
    <span class="c1"># In the code of this class, some special values are used.</span>
    <span class="c1"># * -np.inf (or None) means &quot;I have not started to compute this value&quot;.</span>
    <span class="c1"># * np.nan means &quot;I tried to compute this value, and I decided that I don&#39;t know&quot;.</span>
    <span class="c1"># As for np.inf, it really means + Infinity.</span>
    <span class="c1">#</span>
    <span class="c1"># 1) Methods for IM have an architecture of their own.</span>
    <span class="c1"># 2) Methods for TM and UM have essentially the same architecture and work on variables _candidates_.. and _is_..</span>
    <span class="c1"># 3) Methods for ICM and CM have essentially the same structure and focus on _sufficient_coalition_size_.. and</span>
    <span class="c1"># _necessary_coalition_size_cm.., then on _candidates_.. and _is_..</span>
    <span class="c1"># However, there are subtle differences of architecture between 1, 2 and 3 (cf. their docstrings).</span>

    <span class="c1"># Guideline:</span>
    <span class="c1"># When there is a polynomial exact algorithm, it should be the only option. The default option should be the most</span>
    <span class="c1"># precise algorithm among those running in polynomial time.</span>
    <span class="c1"># Exception: for iia_subset_maximum_size, default option is 2.</span>

    <span class="n">options_parameters</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;iia_subset_maximum_size&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="n">type_checker</span><span class="o">.</span><span class="n">is_number</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="s1">&#39;im_option&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lazy&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;lazy&#39;</span><span class="p">},</span>
        <span class="s1">&#39;tm_option&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lazy&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;exact&#39;</span><span class="p">},</span>
        <span class="s1">&#39;um_option&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lazy&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;lazy&#39;</span><span class="p">},</span>
        <span class="s1">&#39;icm_option&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lazy&#39;</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;lazy&#39;</span><span class="p">},</span>
        <span class="s1">&#39;cm_option&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lazy&#39;</span><span class="p">,</span> <span class="s1">&#39;exact&#39;</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="s1">&#39;lazy&#39;</span><span class="p">}</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">with_two_candidates_reduces_to_plurality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_based_on_rk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">is_based_on_ut_minus1_1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">meets_iia</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">precheck_um</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">precheck_tm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">precheck_icm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">log_identity</span><span class="o">=</span><span class="s1">&#39;RULE&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Log</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_identity</span> <span class="o">=</span> <span class="n">log_identity</span>
        <span class="c1"># Basic properties of the voting system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">with_two_candidates_reduces_to_plurality</span> <span class="o">=</span> <span class="n">with_two_candidates_reduces_to_plurality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span> <span class="o">=</span> <span class="n">is_based_on_rk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_ut_minus1_1</span> <span class="o">=</span> <span class="n">is_based_on_ut_minus1_1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meets_iia</span> <span class="o">=</span> <span class="n">meets_iia</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precheck_um</span> <span class="o">=</span> <span class="n">precheck_um</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precheck_tm</span> <span class="o">=</span> <span class="n">precheck_tm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precheck_icm</span> <span class="o">=</span> <span class="n">precheck_icm</span>
        <span class="c1"># Options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iia_subset_maximum_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_option</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_option</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_option</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_option</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_option</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result_options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Each option used for the RESULT of the election must be stored in self._result_options, even if there is also</span>
        <span class="c1"># an attribute for the option.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_options</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Initialize the computed variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A simple copy of the rule.</span>

<span class="sd">        It is used to compute the results of a virtual election (for tests like IIA, TM, IM...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_result_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the options.</span>

<span class="sd">        Arguments: option1=value1, option2=value2, etc. Checks iff option1, option2 are known in</span>
<span class="sd">        self.options_parameters. For each option in self.options_parameters:</span>
<span class="sd">        * If a value is given, option is set to this value.</span>
<span class="sd">        * Otherwise, the default value is used.</span>
<span class="sd">        N.B.: validity check on the value are not performed here, but in the setter method for the option.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;Initialize options&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">option</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="n">option</span><span class="p">][</span><span class="s1">&#39;default&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown option:&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dict: The options. Key: name of the option. Value: value of the option.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

<div class="viewcode-block" id="Rule.check_option_allowed"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.check_option_allowed">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">check_option_allowed</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a pair (option, value) is allowed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        option : str</span>
<span class="sd">        value : object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Raise an error if the option is not in :attr:`options_parameters`:</span>

<span class="sd">            &gt;&gt;&gt; Rule.check_option_allowed(&#39;not_existing_option&#39;, 42)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ValueError: Option &#39;not_existing_option&#39; is unknown for Rule.</span>

<span class="sd">        Raise an error if the value is not authorized for this option:</span>

<span class="sd">            &gt;&gt;&gt; Rule.check_option_allowed(&#39;cm_option&#39;, &#39;unexpected_value&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ValueError: &#39;cm_option&#39; = &#39;unexpected_value&#39; is not allowed in Rule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">option</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Option </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">option</span><span class="p">)</span><span class="si">}</span><span class="s2"> is unknown for </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">allowed</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="n">option</span><span class="p">][</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span>
        <span class="n">this_value_is_allowed</span> <span class="o">=</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span> <span class="ow">and</span> <span class="n">allowed</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">this_value_is_allowed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">option</span><span class="si">}</span><span class="s2">&#39; = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not allowed in </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rule.log_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.log_">[docs]</a>    <span class="k">def</span> <span class="nf">log_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log corresponding to a particular manipulation method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;_iia_&#39;</span> <span class="ow">in</span> <span class="n">method_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_iia_</span>
        <span class="k">if</span> <span class="s1">&#39;_im_&#39;</span> <span class="ow">in</span> <span class="n">method_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_im_</span>
        <span class="k">if</span> <span class="s1">&#39;_icm_&#39;</span> <span class="ow">in</span> <span class="n">method_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_icm_</span>
        <span class="k">if</span> <span class="s1">&#39;_tm_&#39;</span> <span class="ow">in</span> <span class="n">method_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_tm_</span>
        <span class="k">if</span> <span class="s1">&#39;_um_&#39;</span> <span class="ow">in</span> <span class="n">method_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_um_</span>
        <span class="k">if</span> <span class="s1">&#39;_cm_&#39;</span> <span class="ow">in</span> <span class="n">method_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_cm_</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        profile : Profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span> <span class="o">=</span> <span class="n">profile</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># %% Manipulation criteria of the voting system</span>
    <span class="c1"># In the subclass corresponding to a specific voting system, it is sufficient to redefine to True only the</span>
    <span class="c1"># strongest criteria that are met by the voting system.</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_condorcet_c_ut_rel_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;relative Condorcet criterion with ctb&#39;. I.e.: if a</span>
<span class="sd">        candidate is a :attr:`~svvamp.Profile.condorcet_winner_ut_rel_ctb`, she wins.</span>

<span class="sd">        Implies: :attr:`~meets_condorcet_c_ut_rel`, :attr:`~meets_condorcet_c_ut_abs_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_condorcet_c_rk_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;Condorcet criterion (rk) with ctb&#39;. I.e.: if a</span>
<span class="sd">        candidate is a :attr:`~svvamp.Profile.condorcet_winner_rk_ctb`, she wins.</span>

<span class="sd">        Implies: :attr:`~meets_condorcet_c_rk`, :attr:`~meets_condorcet_c_ut_abs_ctb`,</span>
<span class="sd">        :attr:`~meets_majority_favorite_c_rk_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_condorcet_c_ut_abs_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;absolute Condorcet criterion with ctb&#39;. I.e.: if a</span>
<span class="sd">        candidate is a :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`, she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_rk_ctb`, :attr:`~meets_condorcet_c_ut_rel_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_condorcet_c_ut_abs`, :attr:`~meets_majority_favorite_c_ut_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk_ctb</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_majority_favorite_c_rk_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;majority favorite criterion (rk) with ctb&#39;. I.e.:</span>

<span class="sd">            *   It :attr:`~meets_majority_favorite_c_rk`,</span>
<span class="sd">            *   And if :attr:`~svvamp.Profile.n_v`/2 voters rank candidate 0 first (rk), she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_rk_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_majority_favorite_c_ut_ctb`, :attr:`~meets_majority_favorite_c_rk`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_majority_favorite_c_ut_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;majority favorite criterion (ut) with ctb&#39;. I.e.:</span>

<span class="sd">            *   It :attr:`~meets_majority_favorite_c_ut`,</span>
<span class="sd">            *   And if :attr:`~svvamp.Profile.n_v`/2 voters strictly prefer candidate 0 to all other candidates,</span>
<span class="sd">                she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_ut_abs_ctb`, :attr:`~meets_majority_favorite_c_rk_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_IgnMC_c_ctb`, :attr:`~meets_majority_favorite_c_ut`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs_ctb</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_ignmc_c_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;ignorant majority coalition criterion with ctb&#39;. I.e.:</span>

<span class="sd">            *   It :attr:`~meets_IgnMC_c`,</span>
<span class="sd">            *   And any ignorant coalition of size :attr:`~svvamp.Profile.n_v`/2 can make candidate 0 win.</span>

<span class="sd">        Is implied by: :attr:`~meets_majority_favorite_c_ut_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_InfMC_c_ctb`, :attr:`~meets_IgnMC_c`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_infmc_c_ctb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the &#39;informed majority coalition criterion with ctb&#39;. I.e.:</span>

<span class="sd">            *   It :attr:`~meets_InfMC_c`,</span>
<span class="sd">            *   And any informed coalition of size :attr:`~svvamp.Profile.n_v`/2 can make candidate 0 win.</span>

<span class="sd">        Is implied by: :attr:`~meets_IgnMC_c_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_InfMC_c`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_condorcet_c_ut_rel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the relative Condorcet criterion. I.e. if a candidate is a</span>
<span class="sd">        :attr:`~svvamp.Profile.condorcet_winner_ut_rel`, then she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_ut_rel_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_condorcet_c_ut_abs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_condorcet_c_rk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the Condorcet criterion (rk). I.e. if a candidate is a</span>
<span class="sd">        :attr:`~svvamp.Profile.condorcet_winner_rk`, then she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_rk_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_condorcet_c_ut_abs`, :attr:`~meets_majority_favorite_c_rk`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_condorcet_c_ut_abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the absolute Condorcet criterion. I.e. if a candidate is a</span>
<span class="sd">        :attr:`~svvamp.Profile.condorcet_winner_ut_abs`, then she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_rk`, :attr:`~meets_condorcet_c_ut_rel`,</span>
<span class="sd">        :attr:`~meets_condorcet_c_ut_abs_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_majority_favorite_c_ut`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_majority_favorite_c_rk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the majority favorite criterion (rk). I.e. if strictly more</span>
<span class="sd">        than :attr:`~svvamp.Profile.n_v`/2 voters rank a candidate first (rk), then she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_rk`, :attr:`~meets_majority_favorite_c_rk_ctb`.</span>

<span class="sd">        Implies: :attr:`~_meets_majority_favorite_c_ut`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_majority_favorite_c_ut</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the majority favorite criterion (ut). I.e. if strictly more</span>
<span class="sd">        than :attr:`~svvamp.Profile.n_v`/2 voters strictly prefer a candidate to all others (ut), she wins.</span>

<span class="sd">        Is implied by: :attr:`~meets_condorcet_c_ut_abs`, :attr:`~meets_majority_favorite_c_ut_ctb`,</span>
<span class="sd">        :attr:`~meets_majority_favorite_c_rk`.</span>

<span class="sd">        Implies: :attr:`~meets_IgnMC_c`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_ignmc_c</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the ignorant majority coalition criterion. I.e. any ignorant</span>
<span class="sd">        coalition of size strictly more than :attr:`~svvamp.Profile.n_v`/2 can make any candidate win. See Durand et</span>
<span class="sd">        al.: &#39;Condorcet Criterion and Reduction in Coalitional Manipulability&#39;.</span>

<span class="sd">        *Ignorant* means that they can choose their ballot without knowing what other voters will do.</span>

<span class="sd">        Is implied by: :attr:`~meets_majority_favorite_c_ut`, :attr:`~meets_IgnMC_c_ctb`.</span>

<span class="sd">        Implies: :attr:`~meets_InfMC_c`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">meets_infmc_c</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the voting system meets the informed majority coalition criterion. I.e. any informed</span>
<span class="sd">        coalition of size strictly more than :attr:`~svvamp.Profile.n_v`/2 can make any candidate win. See Durand et</span>
<span class="sd">        al.: &#39;Condorcet Criterion and Reduction in Coalitional Manipulability&#39;.</span>

<span class="sd">        *Informed* means that they know other voters&#39; ballots before choosing their own.</span>

<span class="sd">        Is implied by: :attr:`~meets_IgnMC_c`, :attr:`~meets_InfMC_c_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c_ctb</span>

    <span class="c1"># %% Counting ballots</span>
    <span class="c1">#    Attributes to be implemented in subclasses.</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">scores_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scores of the candidates in the election.</span>

<span class="sd">        See specific documentation for each voting rule. Typical type in most subclasses: 1d or 2d array. Typical</span>
<span class="sd">        behavior in most subclasses:</span>

<span class="sd">        * If ``scores_`` is a 1d array, then ``scores_[c]`` is the numerical score for candidate ``c``.</span>
<span class="sd">        * If ``scores_`` is a 2d array, then ``scores_[:, c]`` is the score vector for candidate ``c``.</span>

<span class="sd">        It is not mandatory to follow this behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># %% Counting ballots</span>
    <span class="c1">#    Attributes with default, but frequently redefined in subclasses.</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">ballots_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ballots cast by the voters.</span>

<span class="sd">        Default type: 2d array of integers. Default behavior:</span>
<span class="sd">        ``ballots[v, k]`` = :attr:`~svvamp.Profile.preferences_rk`\ ``[v, k]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This can be overridden by specific voting systems. This general behavior is ok only for ordinal voting systems</span>
        <span class="c1"># (and even in this case, it can be redefined in favor of something more practical).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute ballots&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_rk</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integer (winning candidate).</span>

<span class="sd">        Default behavior: the candidate with highest value in vector :attr:`scores_` is declared the winner. In case</span>
<span class="sd">        of a tie, the tied candidate with lowest index wins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This general method works only if scores are scalar and the best score wins.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute winner&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">candidates_by_scores_best_to_worst_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of integers. All candidates, sorted from the winner to the last candidate in the election&#39;s result.</span>

<span class="sd">        Default behavior: ``candidates_by_scores_best_to_worst[k]`` is the candidate with ``k``\ :sup:`th` highest</span>
<span class="sd">        value in :attr:`scores_`. By definition, ``candidates_by_scores_best_to_worst[0]`` = :attr:`w_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This can be overridden by specific voting systems. This general method works only if scores are scalar and</span>
        <span class="c1"># the best score wins. If the lowest score wins, then candidates_by_scores_best_to_worst need to be sorted by</span>
        <span class="c1"># ascending score...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute candidates_by_scores_best_to_worst&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">v_might_im_for_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;2d array of booleans. `</span>

<span class="sd">        `v_might_im_for_c_[v, c]`` is True unless it is clearly and easily excluded that ``v`` has an individual</span>
<span class="sd">        manipulation in favor of ``c``. Typically, if ``v`` is not pivotal (at all), then it is False. Specific</span>
<span class="sd">        implementations of this function in subclasses can also test if ``v`` is interested in manipulating for ``c``,</span>
<span class="sd">        but it is not mandatory.</span>

<span class="sd">        A non-trivial redefinition of this function is useful for voting systems where computing IM is costly. For</span>
<span class="sd">        voting systems where it is cheap, it it not worth the effort.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

    <span class="c1"># %% Counting ballots</span>
    <span class="c1">#    Attributes that are almost always computed here in the superclass.</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">score_w_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Score of the sincere winner.</span>

<span class="sd">        Default type: number or 1d array.</span>

<span class="sd">        Default behavior:</span>

<span class="sd">        * If :attr:`scores_` is a 1d array, then ``score_w_`` is :attr:`w_`&#39;s numerical score.</span>
<span class="sd">        * If :attr:`scores_` is a 2d array, then ``score_w_`` is :attr:`w_`&#39;s score vector:</span>
<span class="sd">        ``score_w_ = scores_[:, w_]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Exception: if scores are read in rows (Schulze, Ranked pairs), this needs to be redefined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute winner&#39;s score&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">scores_best_to_worst_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scores of the candidates, from the winner to the last candidate of the election.</span>

<span class="sd">        Default type: 1d or 2d array.</span>

<span class="sd">        Default behavior: ``scores_best_to_worst_`` is derived from :attr:`scores_` and</span>
<span class="sd">        :attr:`candidates_by_scores_best_to_worst_`.</span>

<span class="sd">        If :attr:`scores_` is a 1d array, then so is ``scores_best_to_worst_``. It is defined by</span>
<span class="sd">        ``scores_best_to_worst_`` = ``scores_[candidates_by_scores_best_to_worst_]``. Then by definition,</span>
<span class="sd">        ``scores_best_to_worst_[0]`` = :attr:`score_w_`.</span>

<span class="sd">        If :attr:`scores_` is a 2d array, then so is ``scores_best_to_worst_``. It is defined by</span>
<span class="sd">        ``scores_best_to_worst_`` = ``scores_[:, candidates_by_scores_best_to_worst_]``. Then by definition,</span>
<span class="sd">        ``scores_best_to_worst_[:, 0]`` = :attr:`score_w_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Exception: if scores are read in rows (Schulze, Ranked pairs), this needs to be redefined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute scores_best_to_worst&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">candidates_by_scores_best_to_worst_</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_by_scores_best_to_worst_</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">total_utility_w_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Float. The total utility for the sincere winner :attr:`w_`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">total_utility_c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">mean_utility_w_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Float. The mean utility for the sincere winner :attr:`w_`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">mean_utility_c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">relative_social_welfare_w_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Float. The relative social welfare for the sincere winner :attr:`w_`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">relative_social_welfare_c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>

    <span class="c1"># %% Condorcet efficiency and variants</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_admissible_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the sincere winner :attr:`w_` is Condorcet-admissible.</span>
<span class="sd">        Cf. :attr:`~svvamp.Profile.condorcet_admissible_candidates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_admissible_candidates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_admissible_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` iff the sincere winner :attr:`w_` is not a Condorcet-admissible candidate (whether some</span>
<span class="sd">        exist or not). Cf. :attr:`~svvamp.Profile.condorcet_admissible_candidates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_admissible_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_admissible_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a Condorcet-admissible candidate, despite the fact</span>
<span class="sd">        that at least one exists. Cf. :attr:`~svvamp.Profile.condorcet_admissible_candidates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">nb_condorcet_admissible</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_admissible_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_weak_condorcet_winner_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a Weak Condorcet winner.</span>
<span class="sd">        Cf. :attr:`~svvamp.Profile.weak_condorcet_winners`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">weak_condorcet_winners</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_weak_condorcet_winner_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a Weak Condorcet winner (whether some exist or not).</span>
<span class="sd">        Cf. :attr:`~svvamp.Profile.weak_condorcet_winners`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_weak_condorcet_winner_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_weak_condorcet_winner_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a Weak Condorcet winner, despite the fact that at</span>
<span class="sd">        least one exists. Cf. :attr:`~svvamp.Profile.weak_condorcet_winners`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">nb_weak_condorcet_winners</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_weak_condorcet_winner_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_winner_rk_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.condorcet_winner_rk_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_rk_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_winner_rk_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.condorcet_winner_rk_ctb`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_ctb_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_winner_rk_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the :attr:`~svvamp.Profile.condorcet_winner_rk_ctb`,</span>
<span class="sd">        despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_rk_ctb</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_ctb_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_winner_rk_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.condorcet_winner_rk`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_rk</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_winner_rk_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.condorcet_winner_rk`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_winner_rk_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the :attr:`~svvamp.Profile.condorcet_winner_rk`,</span>
<span class="sd">        despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_rk</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_winner_ut_rel_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_rel_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_winner_ut_rel_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_ctb_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_winner_ut_rel_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the</span>
<span class="sd">        :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`, despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_rel_ctb</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_ctb_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_winner_ut_rel_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.condorcet_winner_ut_rel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_rel</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_winner_ut_rel_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.condorcet_winner_ut_rel`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_winner_ut_rel_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the :attr:`~svvamp.Profile.condorcet_winner_ut_rel`,</span>
<span class="sd">        despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_rel</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_winner_ut_abs_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_abs_ctb</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_winner_ut_abs_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_ctb_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_winner_ut_abs_ctb_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the</span>
<span class="sd">        :attr:`~svvamp.Profile.condorcet_winner_ut_abs_ctb`, despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_abs_ctb</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_ctb_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_condorcet_winner_ut_abs_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.condorcet_winner_ut_abs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_abs</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_condorcet_winner_ut_abs_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.condorcet_winner_ut_abs`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_condorcet_winner_ut_abs_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the :attr:`~svvamp.Profile.condorcet_winner_ut_abs`,</span>
<span class="sd">        despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_abs</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_resistant_condorcet_winner_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is a :attr:`~svvamp.Profile.resistant_condorcet_winner`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">resistant_condorcet_winner</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_is_not_resistant_condorcet_winner_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not a :attr:`~svvamp.Profile.resistant_condorcet_winner`</span>
<span class="sd">        (whether one exists or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_resistant_condorcet_winner_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">w_missed_resistant_condorcet_winner_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. True iff the sincere winner :attr:`w_` is not the</span>
<span class="sd">        :attr:`~svvamp.Profile.resistant_condorcet_winner`, despite the fact that she exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">resistant_condorcet_winner</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_resistant_condorcet_winner_</span>

<div class="viewcode-block" id="Rule.demo_profile_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.demo_profile_">[docs]</a>    <span class="k">def</span> <span class="nf">demo_profile_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Demonstrate the attributes of the loaded profile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_depth : int</span>
<span class="sd">            Integer from 0 (basic info) to 3 (verbose).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print_big_title</span><span class="p">(</span><span class="s1">&#39;Profile Class&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">demo</span><span class="p">(</span><span class="n">log_depth</span><span class="o">=</span><span class="n">log_depth</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rule.demo_results_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.demo_results_">[docs]</a>    <span class="k">def</span> <span class="nf">demo_results_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Demonstrate the methods related to the result of the election (without manipulation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_depth : int</span>
<span class="sd">            Integer from 0 (basic info) to 3 (verbose).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_log_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_depth</span> <span class="o">=</span> <span class="n">log_depth</span>

        <span class="n">print_big_title</span><span class="p">(</span><span class="s1">&#39;Election Results&#39;</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Results&quot;</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;profile_.preferences_ut (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_ut</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;profile_.preferences_rk (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_rk</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;ballots =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ballots_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;scores =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;candidates_by_scores_best_to_worst&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_by_scores_best_to_worst_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;scores_best_to_worst&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scores_best_to_worst_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;score_w =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_w_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total_utility_w =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_utility_w_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Condorcet efficiency (rk)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;condorcet_winner_rk_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_rk_ctb</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_winner_rk_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_winner_rk_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_rk_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_winner_rk_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_winner_rk_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;condorcet_winner_rk =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_rk</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_winner_rk =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_winner_rk =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_rk_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_winner_rk =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_winner_rk_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Condorcet efficiency (relative)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;condorcet_winner_ut_rel_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_rel_ctb</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_winner_ut_rel_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_winner_ut_rel_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_ut_rel_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_winner_ut_rel_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_winner_ut_rel_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;condorcet_winner_ut_rel =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_rel</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_winner_ut_rel =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_winner_ut_rel =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_ut_rel_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_winner_ut_rel =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_winner_ut_rel_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Condorcet efficiency (absolute)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;condorcet_admissible_candidates =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_admissible_candidates</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_admissible =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_admissible_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_admissible =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_admissible_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_admissible =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_admissible_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;weak_condorcet_winners =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">weak_condorcet_winners</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_weak_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_weak_condorcet_winner_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_weak_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_weak_condorcet_winner_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_weak_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_weak_condorcet_winner_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;condorcet_winner_ut_abs_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_abs_ctb</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_winner_ut_abs_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_winner_ut_abs_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_ut_abs_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_winner_ut_abs_ctb =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_winner_ut_abs_ctb_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;condorcet_winner_ut_abs =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">condorcet_winner_ut_abs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_condorcet_winner_ut_abs =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_condorcet_winner_ut_abs =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_ut_abs_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_condorcet_winner_ut_abs =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_condorcet_winner_ut_abs_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;resistant_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">resistant_condorcet_winner</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_resistant_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_resistant_condorcet_winner_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_is_not_resistant_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_resistant_condorcet_winner_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w_missed_resistant_condorcet_winner =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_missed_resistant_condorcet_winner_</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_depth</span> <span class="o">=</span> <span class="n">old_log_depth</span></div>

    <span class="c1"># %% Setting the options</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iia_subset_maximum_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Float or ``numpy.inf``. Maximum size of any subset of candidates that is used to compute</span>
<span class="sd">        :meth:`not_iia` (and related methods). For a given voting system, this attribute has no</span>
<span class="sd">        effect if there is an exact algorithm running in polynomial time implemented in SVVAMP.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iia_subset_maximum_size</span>

    <span class="nd">@iia_subset_maximum_size</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">iia_subset_maximum_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iia_subset_maximum_size</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;Setting iia_subset_maximum_size =&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iia_subset_maximum_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_iia_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for iia_subset_maximum_size: &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot; (number or np.inf expected).&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">im_option</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Option used to compute :meth:`is_im_` and related methods.</span>

<span class="sd">        To know what options are accepted for a given voting system, use :attr:`options_parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_option</span>

    <span class="nd">@im_option</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">im_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_option</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="s1">&#39;im_option&#39;</span><span class="p">][</span><span class="s1">&#39;allowed&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;Setting im_option =&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_option</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_im_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for im_option: &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tm_option</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Option used to compute :meth:`is_tm_` and related methods.</span>

<span class="sd">        To know what options are accepted for a given voting system, use :attr:`options_parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_option</span>

    <span class="nd">@tm_option</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tm_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_option</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="s1">&#39;tm_option&#39;</span><span class="p">][</span><span class="s1">&#39;allowed&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;Setting tm_option =&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_option</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_tm_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_option</span> <span class="o">!=</span> <span class="s1">&#39;exact&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_tm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_cm_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for tm_option: &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">um_option</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Option used to compute :meth:`is_um_` and related methods.</span>

<span class="sd">        To know what options are accepted for a given voting system, use :attr:`options_parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_option</span>

    <span class="nd">@um_option</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">um_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_option</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="s1">&#39;um_option&#39;</span><span class="p">][</span><span class="s1">&#39;allowed&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;Setting um_option =&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_option</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_um_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_option</span> <span class="o">!=</span> <span class="s1">&#39;exact&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_um</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_cm_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for um_option: &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">icm_option</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Option used to compute :meth:`is_icm_` and related methods.</span>

<span class="sd">        To know what options are accepted for a given voting system, use :attr:`options_parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_option</span>

    <span class="nd">@icm_option</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">icm_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_option</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="s1">&#39;icm_option&#39;</span><span class="p">][</span><span class="s1">&#39;allowed&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;Setting icm_option =&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_icm_option</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_icm_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_option</span> <span class="o">!=</span> <span class="s1">&#39;exact&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_icm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_cm_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for icm_option: &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cm_option</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Option used to compute :meth:`is_cm_` and related methods.</span>

<span class="sd">        To know what options are accepted for a given voting system, use :attr:`options_parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_option</span>

    <span class="nd">@cm_option</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cm_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_option</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="p">[</span><span class="s1">&#39;cm_option&#39;</span><span class="p">][</span><span class="s1">&#39;allowed&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;Setting cm_option =&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_option</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete_cache</span><span class="p">(</span><span class="n">contains</span><span class="o">=</span><span class="s1">&#39;_cm_&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for cm_option: &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># %% Independence of Irrelevant Alternatives (IIA)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">log_iia_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Parameters used to compute :meth:`is_not_iia_` and related methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;iia_subset_maximum_size = &quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iia_subset_maximum_size</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_not_iia_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` if there exists a subset of candidates including the sincere winner</span>
<span class="sd">        :attr:`w`_, such that if the election is held with this subset of candidates, then :attr:`w_` is not the</span>
<span class="sd">        winner anymore. If the algorithm cannot decide, then the result is ``numpy.nan``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_iia_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_iia_</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_iia_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. Cf. :attr:`is_not_iia`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_</span><span class="p">[</span><span class="s1">&#39;is_iia&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">example_winner_iia_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integer (candidate). If the election is not IIA, ``example_winner_iia`` is the winner corresponding to the</span>
<span class="sd">        counter-example ``example_subset_iia``. If the election is IIA (or if the algorithm cannot decide), then</span>
<span class="sd">        ``example_winner_iia = numpy.nan``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_</span><span class="p">[</span><span class="s1">&#39;example_winner_iia&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">example_subset_iia_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans. If the election is not IIA, ``example_subset_iia`` provides a subset of candidates</span>
<span class="sd">        breaking IIA. ``example_subset_iia[c]`` is ``True`` iff candidate ``c`` belongs to the subset. If the</span>
<span class="sd">        election is IIA (or if the algorithm cannot decide), then ``example_subset_iia = numpy.nan``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_</span><span class="p">[</span><span class="s1">&#39;example_subset_iia&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_compute_iia_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute iia.</span>

<span class="sd">        :return: a dictionary whose keys are &#39;is_iia&#39;, &#39;example_subset_iia&#39;, &#39;example_winner_iia&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute IIA&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_iia</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA is guaranteed for this voting system.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a Condorcet winner.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_ctb_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a Condorcet winner (ctb).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a relative Condorcet winner.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_rel_ctb_</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a relative Condorcet winner (ctb).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a Condorcet winner (vtb).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_ctb_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a Condorcet winner (vtb, ctb).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a majority favorite.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a majority favorite (vtb).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a majority favorite (ctb) (w = 0).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="s2">&quot;IIA guaranteed: w is a majority favorite (vtb, ctb)&quot;</span>
                                                          <span class="s2">&quot;(w = 0).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_two_candidates_reduces_to_plurality</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_winner_rk_ctb_</span><span class="p">:</span>
                <span class="c1"># For subsets of 2 candidates, we use the matrix of victories to gain time.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IIA failure found by Condorcet failure (rk, ctb).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">is_iia</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">example_winner_iia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_victories_rk_ctb</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">example_subset_iia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">example_subset_iia</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">example_subset_iia</span><span class="p">[</span><span class="n">example_winner_iia</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;is_iia&#39;</span><span class="p">:</span> <span class="n">is_iia</span><span class="p">,</span> <span class="s1">&#39;example_subset_iia&#39;</span><span class="p">:</span> <span class="n">example_subset_iia</span><span class="p">,</span>
                        <span class="s1">&#39;example_winner_iia&#39;</span><span class="p">:</span> <span class="n">example_winner_iia</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IIA: subsets of size 2 are ok because w is a Condorcet winner (rk, ctb).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_</span><span class="p">(</span><span class="n">subset_minimum_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_iia_aux_</span><span class="p">(</span><span class="n">subset_minimum_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_iia_aux_when_guaranteed_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Auxiliary function of _compute_iia_, used when IIA is guaranteed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        message : str</span>
<span class="sd">            A log message explaining why IIA is guaranteed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary whose keys are &#39;is_iia&#39;, &#39;example_subset_iia&#39;, &#39;example_winner_iia&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;is_iia&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;example_subset_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;example_winner_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_compute_iia_aux_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset_minimum_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Auxiliary function of _compute_iia_: real work.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset_minimum_size : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary whose keys are &#39;is_iia&#39;, &#39;example_subset_iia&#39;, &#39;example_winner_iia&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Tests all subsets from size ``subset_minimum_size`` to ``self.iia_subset_maximum_size``. If</span>
<span class="sd">        ``self.iia_subset_maximum_size`` &lt; ``C - 1``, then the algorithm may not be able to decide whether</span>
<span class="sd">        the election is IIA or not: in this case, we may have is_iia = NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;IIA: Use _compute_iia_aux_ with subset_minimum_size =&quot;</span><span class="p">,</span> <span class="n">subset_minimum_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">subset_maximum_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iia_subset_maximum_size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">n_c_reduced</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subset_minimum_size</span><span class="p">,</span> <span class="n">subset_maximum_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">&lt;=</span> <span class="n">n_c_reduced</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">candidates_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_c_reduced</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">candidates_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">n_c_reduced</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]))</span>
            <span class="k">while</span> <span class="n">candidates_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_winner_of_subset_</span><span class="p">(</span><span class="n">candidates_r</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">w_r</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IIA failure found&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">example_subset_iia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates_r</span><span class="p">:</span>
                        <span class="n">example_subset_iia</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;is_iia&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;example_winner_iia&#39;</span><span class="p">:</span> <span class="n">w_r</span><span class="p">,</span> <span class="s1">&#39;example_subset_iia&#39;</span><span class="p">:</span> <span class="n">example_subset_iia</span><span class="p">}</span>
                <span class="n">candidates_r</span> <span class="o">=</span> <span class="n">compute_next_subset_with_w</span><span class="p">(</span><span class="n">candidates_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">n_c_reduced</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="c1"># We have not found a counter-example...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iia_subset_maximum_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IIA: I have found no counter-example, but we have not explored all possibilities&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;is_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;example_winner_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;example_subset_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IIA is guaranteed.&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;is_iia&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;example_winner_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;example_subset_iia&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_compute_winner_of_subset_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidates_r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the winner for a subset of candidates.</span>

<span class="sd">        This function is internally used to compute Independence of Irrelevant Alternatives (IIA).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        candidates_r : list or ndarray</span>
<span class="sd">            1d array of integers. ``candidates_r[k]`` is the ``k``-th candidate of the subset. This vector must be</span>
<span class="sd">            sorted in ascending order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        w_r : int</span>
<span class="sd">            Candidate who wins the sub-election defined by ``candidates_r``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;IIA: Compute winner of subset &quot;</span><span class="p">,</span> <span class="n">candidates_r</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">candidates_r</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">profile</span><span class="o">=</span><span class="n">ProfileSubsetCandidates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="p">,</span> <span class="n">candidates_r</span><span class="p">))</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>

    <span class="c1"># %% Manipulation: common features</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">v_wants_to_help_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;2d array of booleans. ``v_wants_to_help_c[v, c]`` is ``True`` iff voter ``v`` strictly prefers candidate</span>
<span class="sd">        ``c`` to the sincere winner :attr:`w_`. If ``v`` attributes the same utility to ``c`` and ``w_``, then ``v``</span>
<span class="sd">        is not interested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute v_wants_to_help_c&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_ut</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_ut</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">losing_candidates_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d of Integers. List of losing candidates, in a decreasing order of (heuristic) dangerousness</span>

<span class="sd">        This attribute is mostly intended for SVVAMP developers. It is used in most manipulation algorithms. The idea</span>
<span class="sd">        is to try first the candidates for whom we think manipulation is more likely to succeed, in order to gain time.</span>

<span class="sd">        Losing candidates are sorted from the &#39;most dangerous&#39; to the &#39;least dangerous&#39; (for the sincere winner</span>
<span class="sd">        :attr:`w_`). By default, they are sorted by their score against :attr:`w_` in the</span>
<span class="sd">        :attr:`~svvamp.Profile.matrix_duels_ut` (which is the number of potential manipulators for a given</span>
<span class="sd">        candidate). This behavior can be redefined in the subclass implementing a specific voting system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute ordered list of losing candidates&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">c_has_supporters_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans. ``c_has_supporters_[c]`` is ``True`` iff at least one voter prefers candidate ``c`` to</span>
<span class="sd">        the sincere winner :attr:`w_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute c_has_supporters_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_sufficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sufficient_array</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update an array _sufficient_coalition_size_.. for candidate c.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sufficient_array : list or ndarray</span>
<span class="sd">            An array like ``_sufficient_coalition_size_cm`` or ``_sufficient_coalition_size_icm``.</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>
<span class="sd">        value : int</span>
<span class="sd">            If the number of manipulators is &gt;= value, then manipulation (CM or ICM) is possible.</span>
<span class="sd">        message : str</span>
<span class="sd">            A message that can be displayed if ``sufficient_array[c]`` is actually updated.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Perform ``sufficient_array[c] = min(sufficient_array[c], value)``. If ``sufficient_array[c]`` is actually</span>
<span class="sd">        updated, i.e. iff ``value`` is strictly lower that the former value of ``sufficient_array[c]``, then:</span>
<span class="sd">        send ``message`` and ``value`` to ``self.mylogv (with detail level=3)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">sufficient_array</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="n">sufficient_array</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_necessary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">necessary_array</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update an array _necessary_coalition_size_.. for candidate c.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        necessary_array : list or ndarray</span>
<span class="sd">            An array like ``_necessary_coalition_size_cm`` or ``_necessary_coalition_size_icm``.</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>
<span class="sd">        value : int</span>
<span class="sd">            If the number of manipulators is &lt; value, then manipulation (CM or ICM) is impossible.</span>
<span class="sd">        message : str</span>
<span class="sd">            A message that can be displayed if ``necessary_array[c]`` is actually updated.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Perform ``necessary_array[c] = max(necessary_array[c], value)``. If ``necessary_array[c]`` is actually updated,</span>
<span class="sd">        i.e. iff ``value`` is strictly greater that the former value of ``necessary_array[c]``, then: send ``message``</span>
<span class="sd">        and ``value`` to ``self.mylogv (with detail level = 3)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">necessary_array</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="n">necessary_array</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># %% Individual manipulation (IM)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">log_im_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Parameters used to compute :meth:`is_im_` and related methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;im_option = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_option</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_im_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean. ``True`` if there exists a voter who can and wants to manipulate, ``False`` otherwise. If the</span>
<span class="sd">        algorithm cannot decide, then ``numpy.nan``.</span>

<span class="sd">        Voter ``v`` can and wants to manipulate for candidate ``c`` iff:</span>

<span class="sd">            *   ``v`` strictly prefers ``c`` to :attr:`w_` (in the sense of :attr:`~svvamp.Profile.preferences_ut`).</span>
<span class="sd">            *   And by changing her vote, she can make ``c`` win instead of :attr:`w_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;is_im_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.is_im_c_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_im_c_">[docs]</a>    <span class="k">def</span> <span class="nf">is_im_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Individual manipulation, focus on one candidate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or nan</span>
<span class="sd">            ``candidates_im[c]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;is_im_c_&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">])</span></div>

<div class="viewcode-block" id="Rule.is_im_c_with_voters_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_im_c_with_voters_">[docs]</a>    <span class="k">def</span> <span class="nf">is_im_c_with_voters_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Individual manipulation, focus on one candidate, with details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (``candidates_im[c]``, ``v_im_for_c[:, c]``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[:,</span> <span class="n">c</span><span class="p">])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;is_im_c_with_voters_&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">voters_im_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans (or ``numpy.nan``). ``voters_im_[v]`` is ``True`` if voter ``v`` can and wants to</span>
<span class="sd">        manipulate for at least one candidate, ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_voters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;im_with_voters_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">candidates_im_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans (or ``numpy.nan``). ``candidates_im[c]`` is ``True`` if there exists a voter who can</span>
<span class="sd">        manipulate for candidate ``c``, ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan``. For</span>
<span class="sd">        the sincere winner :attr:`w_`, we have by convention ``candidates_im_[w_] = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_candidates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;im_with_candidates_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">v_im_for_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;2d array of booleans. ``v_im_for_c_[v, c]`` is ``True`` if voter ``v`` can manipulate for candidate ``c``,</span>
<span class="sd">        ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan``. For the sincere winner :attr:w_`,</span>
<span class="sd">        we have by convention ``v_im_for_c_[v, w_] = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_full</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v_im_for_c_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.is_im_v_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_im_v_">[docs]</a>    <span class="k">def</span> <span class="nf">is_im_v_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Individual manipulation, focus on one voter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : int</span>
<span class="sd">            Voter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or nan</span>
<span class="sd">            ``voters_im[v]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_v_</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span> <span class="n">stop_if_true</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">])</span></div>

<div class="viewcode-block" id="Rule.is_im_v_with_candidates_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_im_v_with_candidates_">[docs]</a>    <span class="k">def</span> <span class="nf">is_im_v_with_candidates_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Individual manipulation, focus on one voter, with details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : int</span>
<span class="sd">            Voter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (``voters_im[v]``, ``v_im_for_c[v, :]``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_v_</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span> <span class="n">stop_if_true</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_im_is_initialized_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize IM variables and do preliminary checks.</span>

<span class="sd">        Since it is a cached property, the code is run only the first time IM is launched (whatever the  mode).</span>

<span class="sd">        * ``_is_im`` --&gt; False or True if we know, -inf otherwise.</span>
<span class="sd">        * ``_candidates_im[c]`` --&gt; True of False if we know, -inf otherwise.</span>
<span class="sd">        * ``_voters_im[v]`` --&gt; True of False if we know, -inf otherwise.</span>
<span class="sd">        * ``_v_im_for_c[v, c]`` --&gt; True or False if we know, -inf otherwise.</span>

<span class="sd">        It is mandatory that ``_v_im_for_c[v, c]`` is False if voter ``c`` does not prefer ``c`` to the sincere winner</span>
<span class="sd">        ``w_``. Other kinds of checks are optional if this method is redefined in subclasses.</span>

<span class="sd">        If ``_candidates_im`` and ``_is_im`` are totally decided to True or False, then</span>
<span class="sd">        ``_im_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IM: Initialize&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_voters</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_full</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_preliminary_checks_general_</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_im_preliminary_checks_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for IM. Only first time IM is launched.</span>

<span class="sd">        Can update some ``_v_im_for_c[v, c]`` to True or False (instead of -inf). In particular, it is mandatory that</span>
<span class="sd">        it is updated to False if voter ``v`` does not prefer ``c`` to the sincere winner ``w``.</span>

<span class="sd">        * If ``_v_im_for_c[v, c]`` becomes True, then ``_candidates_im[c]`` and ``_voters_im[v]`` must become True. If</span>
<span class="sd">          ``_candidates_im[c]`` or ``_voters_im[v]`` becomes True, then ``_is_im`` must become True.</span>
<span class="sd">        * If ``_is_im`` becomes True, it is not necessary to update a specific ``_candidates_im[c]`` or</span>
<span class="sd">          ``_voters_im[v]``. If ``_candidates_im[c]`` or ``_voters_im[v]`` becomes True, it is not necessary to update</span>
<span class="sd">          a specific ``_v_im_for_c[v, c]``.</span>
<span class="sd">        * If ``_is_im`` becomes False, then ``_candidates_im[:]`` and ``_voters_im[:]`` must become False. If</span>
<span class="sd">          ``_candidates_im[c]`` becomes False, then ``_v_im_for_c[:, c]`` must become False. ``If _voters_im[v]``</span>
<span class="sd">           becomes False, then ``_v_im_for_c[v, :]`` must become False.</span>
<span class="sd">        * If for a candidate ``c`` and all voters ``v``, all ``_v_im_for_c[v, c]`` become False, then</span>
<span class="sd">          ``_candidates_im[c]`` must be updated to False. If for all candidates ``c``, ``_candidates_im[c]`` becomes</span>
<span class="sd">          False, then ``_is_im`` must be updated to False.</span>
<span class="sd">        * Similarly, if for a voter ``v`` and all candidates ``c``, all ``_v_im_for_c[v, c]`` become False,</span>
<span class="sd">          then ``_voters_im[v]`` must become False. If for all voters ``v``, ``_voters_im[v]`` becomes False, then</span>
<span class="sd">          ``_is_im`` must be updated to False.</span>
<span class="sd">        * If ``_v_im_for_c``, ``_candidates_im`` and ``_is_im`` are totally decided to True or False, then</span>
<span class="sd">          ``_im_was_computed_with_candidates``, ``_im_was_computed_with_voters`` and ``_im_was_computed_full`` should</span>
<span class="sd">          become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform some preliminary checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_might_im_for_c_</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_preliminary_checks_general_subclass_</span><span class="p">()</span>
        <span class="c1"># Update &#39;False&#39; answers for _candidates_im, _voters_im and _is_im</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IM: preliminary checks: IM is impossible.&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_voters</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_full</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogm</span><span class="p">(</span><span class="s1">&#39;_v_im_for_c =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_im_preliminary_checks_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for IM. Only first time IM is launched.</span>

<span class="sd">        Can update some ``_v_im_for_c[v, c]`` to True or False (instead of -inf).</span>

<span class="sd">        True must be propagated from specific to general, False must be propagated from general to specific. I.e.:</span>
<span class="sd">        * If ``_v_im_for_c[v, c]`` becomes True, then ``_candidates_im[c]`` and ``_voters_im[v]`` must become True.</span>
<span class="sd">          If ``_candidates_im[c]`` or ``_voters_im[v]`` becomes True, then ``_is_im must`` become True.</span>
<span class="sd">        * If ``_is_im`` becomes False, then ``_candidates_im[:]`` and ``_voters_im[v]`` must become False. If</span>
<span class="sd">          ``_candidates_im[c]`` or ``_voters_im[v]`` becomes False, then ``_v_im_for_c[:, c]`` must become False.</span>

<span class="sd">        If for a candidate ``c`` and all voters ``v``, all ``_v_im_for_c[v, c]`` become False, it is not necessary to</span>
<span class="sd">        update ``_candidates_im[c]`` to False (and it is not necessary to update ``_is_im``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_im_initialize_v_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the IM loop for voter v and do preliminary checks. Launched every time we work on voter v.</span>

<span class="sd">        * If the voting system is ordinal and voter ``v`` has the same ordinal preferences as previous voter ``v - 1``,</span>
<span class="sd">          then update the line ``_v_im_for_c[v, :]`` with what we know for ``v - 1``.</span>
<span class="sd">        * Preliminary checks: try to decide some ``_v_im_for_c[v, c]``. If ``_v_im_for_c[v, c]`` becomes True, then</span>
<span class="sd">          ``_candidates_im[c]``, ``_voters_im[v]`` and ``_is_im`` must become True as well. In the other cases, it is</span>
<span class="sd">          not necessary to update ``_candidates_im[c]`` and ``_is_im``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;IM: Voter =&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Check if v is identical to previous voter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">v_has_same_ordinal_preferences_as_previous_voter</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IM: Identical to previous voter&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">decided_previous_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">decided_previous_v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">decided_previous_v</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Preliminary checks on v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_preliminary_checks_v_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_im_preliminary_checks_v_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;IM: preliminary checks for voter v.</span>

<span class="sd">        Try to decide some ``_v_im_for_c[v, c]``. If ``_v_im_for_c[v, c]`` becomes True, then ``_candidates_im[c]``,</span>
<span class="sd">        ``_voters_im[v]`` and ``_is_im`` must become True as well. In the other cases, it is not necessary to update</span>
<span class="sd">        ``_candidates_im[c]``, ``_voters_im[c]`` and ``_is_im``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Nothing smart for the moment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_preliminary_checks_v_subclass_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_im_preliminary_checks_v_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;IM: preliminary checks for voter v.</span>

<span class="sd">        Try to decide some ``_v_im_for_c[v, c]``. If ``_v_im_for_c[v, c]`` becomes True, then ``_candidates_im[c]``,</span>
<span class="sd">        ``_voters_im[v]`` and ``_is_im`` must become True as well. In the other cases, it is not necessary to update</span>
<span class="sd">        ``_candidates_im[c]``, ``_voters_im[c]`` and ``_is_im``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_im_main_work_v_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in IM loop for voter v.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : int</span>
<span class="sd">            Voter.</span>
<span class="sd">        c_is_wanted : list or ndarray</span>
<span class="sd">            1d array of booleans. If for all ``c`` such that ``c_is_wanted[c]`` is True, ``_v_im_for_c[v, c]`` is</span>
<span class="sd">            decided, then we are authorized to get out.</span>
<span class="sd">        nb_wanted_undecided : int</span>
<span class="sd">            Number of &#39;wanted&#39; candidates ``c`` such that ``_v_im_for_c[v, c]`` is not decided yet.</span>
<span class="sd">        stop_if_true : bool</span>
<span class="sd">            If True, then as soon as a True is found for a &#39;wanted&#39; candidate, we are authorized to get out.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Try to decide ``_v_im_for_c[v, :]``. At the end, ``_v_im_for_c[v, c]`` can be True, False, NaN or -inf (we may</span>
<span class="sd">        not have decided for all candidates).</span>

<span class="sd">        If ``_v_im_for_c[v, c]`` becomes True, then ``_candidates_im[c]``, ``_voters_im[v]`` and ``_is_im`` must become</span>
<span class="sd">        True. In the other cases, it is not necessary to update ``_candidates_im[c]``, ``_voters_im[v]`` and ``_is_im``</span>
<span class="sd">        (even if ``_v_im_for_c[v, c]`` becomes NaN).</span>

<span class="sd">        Each time a wanted candidate is decided (to True, False or NaN), decrement ``nb_wanted_undecided``. When it</span>
<span class="sd">        reaches 0, we may get out. If a wanted candidate is decided to True and ``stop_if_true``, then we may get out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># N.B.: in some subclasses, it is possible to try one method, then another one if the first one fails,</span>
        <span class="c1"># etc. In this general class, we will simply do a switch between &#39;lazy&#39; and &#39;exact&#39;.</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_im_main_work_v_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_option</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">)</span>
        <span class="c1"># Launch a sub-method like _im_main_work_v_lazy, etc.</span>

    <span class="c1"># noinspection PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">_im_main_work_v_lazy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in IM loop for voter v, with option &#39;lazy&#39;. Cf. :meth:`_im_main_work_v_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When we don&#39;t know, we decide that we don&#39;t know!</span>
        <span class="n">neginf_to_nan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_im_main_work_v_exact_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in IM loop for voter v, with option &#39;exact&#39;. Cf. :meth:`_im_main_work_v_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_main_work_v_exact_rankings_</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_ut_minus1_1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
            <span class="c1"># have their own `_im_main_work_v_` method, so they do not use this.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_main_work_v_exact_utilities_minus1_1_</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_im_main_work_v_exact_rankings_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in IM loop for voter v, with option &#39;exact&#39;, for a voting system based only on strict</span>
<span class="sd">        rankings. Cf. :meth:`_im_main_work_v_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preferences_borda_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_borda_rk</span><span class="p">)</span>
        <span class="n">ballot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">))</span>
        <span class="n">ballot_favorite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">ballot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Loop on possible ballots</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;IM: Ballot =&quot;</span><span class="p">,</span> <span class="n">ballot</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">preferences_borda_test</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ballot</span>
            <span class="n">w_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">profile</span><span class="o">=</span><span class="n">Profile</span><span class="p">(</span><span class="n">preferences_ut</span><span class="o">=</span><span class="n">preferences_borda_test</span><span class="p">))</span><span class="o">.</span><span class="n">w_</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w_test</span><span class="p">]):</span>
                <span class="c1"># Implicitly, it also means that v prefers c to w (cf. specifications of _im_initialize_general).</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w_test</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">w_test</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;IM found for c =&quot;</span><span class="p">,</span> <span class="n">w_test</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c_is_wanted</span><span class="p">[</span><span class="n">w_test</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">stop_if_true</span><span class="p">:</span>
                        <span class="k">return</span>
                    <span class="n">nb_wanted_undecided</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">nb_wanted_undecided</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>  <span class="c1"># We know everything we want for this voter</span>
            <span class="n">ballot</span><span class="p">,</span> <span class="n">ballot_favorite</span> <span class="o">=</span> <span class="n">compute_next_borda_clever</span><span class="p">(</span><span class="n">ballot</span><span class="p">,</span> <span class="n">ballot_favorite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
        <span class="c1"># If we reach this point, we have tried all ballots, so if we have not found a manipulation for ``c``, it is</span>
        <span class="c1"># not possible. Next instruction replaces all -Inf with 0.</span>
        <span class="n">neginf_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_im_main_work_v_exact_utilities_minus1_1_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span>
                                                  <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in IM loop for voter v, with option &#39;exact&#39;, for a voting system based only on utilities</span>
<span class="sd">        and where it is optimal for a c-manipulator to pretend that ``c`` has utility 1 and other candidates utility 0.</span>
<span class="sd">        Cf. :meth:`_im_main_work_v`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
        <span class="c1"># have their own `_im_main_work_v_` method, so they do not use this.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
        <span class="n">preferences_ut_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_ut</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c_is_wanted</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="c1"># Implicitly, it also means that v prefers c to w (cf. specifications of _im_initialize_general).</span>
            <span class="n">preferences_ut_test</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">preferences_ut_test</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">w_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">Profile</span><span class="p">(</span><span class="n">preferences_ut</span><span class="o">=</span><span class="n">preferences_ut_test</span><span class="p">))</span><span class="o">.</span><span class="n">w_</span>
            <span class="k">if</span> <span class="n">w_test</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IM found&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stop_if_true</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">nb_wanted_undecided</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nb_wanted_undecided</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_compute_im_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute IM.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str</span>
<span class="sd">            Name of the method calling _compute_im.</span>
<span class="sd">        c : int or None</span>
<span class="sd">            If integer, then we only want to study IM for this candidate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute IM&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span><span class="p">):</span>
            <span class="c1"># Prepare work</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;is_im_&#39;</span><span class="p">:</span>
                <span class="n">c_is_wanted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">stop_if_true</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;is_im_c_&#39;</span><span class="p">,</span> <span class="s1">&#39;is_im_c_with_voters_&#39;</span><span class="p">}:</span>
                <span class="n">c_is_wanted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">c_is_wanted</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">stop_if_true</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;im_with_voters_&#39;</span><span class="p">:</span>
                <span class="n">c_is_wanted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">stop_if_true</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;im_with_candidates_&#39;</span><span class="p">:</span>
                <span class="n">c_is_wanted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">)</span>
                <span class="n">stop_if_true</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;v_im_for_c_&#39;</span><span class="p">:</span>
                <span class="n">c_is_wanted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="n">stop_if_true</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># This should not happen.</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="c1"># Work</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_im_v_</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">)</span>
            <span class="c1"># Conclude for v</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;is_im_&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span><span class="p">):</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;is_im_c_&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;im_with_candidates_&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">return</span>
        <span class="c1"># Conclude: update _candidates_im and _is_im if possible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losing_candidates_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]))):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">))):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_full</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_voters</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_voters</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_im</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_im_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_compute_im_v_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute IM for voter v.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : int</span>
<span class="sd">            Voter.</span>
<span class="sd">        c_is_wanted : list or ndarray</span>
<span class="sd">            1d array of booleans. If for all ``c`` such that ``c_is_wanted[c]`` is True, ``_v_im_for_c[v, c]`` is</span>
<span class="sd">            decided, then we are authorized to get out.</span>
<span class="sd">        stop_if_true : bool</span>
<span class="sd">            If True, then as soon as a True is found for a &#39;wanted&#39; candidate, we are authorized to get out.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Try to decide ``_v_im_for_c[v, :]``. At the end, ``_v_im_for_c[v, c]`` can be True, False, NaN or -inf (we may</span>
<span class="sd">        have not decided for all candidates). At the end, ``_voters_im[v]`` must be consistent with what we know about</span>
<span class="sd">        ``_v_im_for_c[v, :]`` (True, False, NaN or -inf).</span>

<span class="sd">        If ``_v_im_for_c[v, c]`` becomes True, then ``_candidates_im[c]`` and ``_is_im`` must become True. In the other</span>
<span class="sd">        cases, it is not necessary to update ``_candidates_im[c]``, and ``_is_im`` (even if ``_v_im_for_c[v, c]``</span>
<span class="sd">        becomes NaN).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_initialize_v_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">nb_wanted_undecided</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nb_wanted_undecided</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;IM: Job already done&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;IM: Preliminary checks: Still some work for v =&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_im_main_work_v_</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c_is_wanted</span><span class="p">,</span> <span class="n">nb_wanted_undecided</span><span class="p">,</span> <span class="n">stop_if_true</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:],</span> <span class="kc">False</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v_im_for_c</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="p">:]))):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_voters_im</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># %% Trivial Manipulation (TM)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">log_tm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Parameters used to compute :meth:`is_tm_` and related methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;tm_option = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_option</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_tm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean (or ``numpy.nan``). ``True`` if TM is possible, ``False`` otherwise. If the algorithm cannot decide,</span>
<span class="sd">        then ``numpy.nan`` (but as of now, this value is never used for TM).</span>

<span class="sd">        For ordinal voting systems, we call *trivial manipulation* for candidate ``c`` against :attr:`w_` the fact of</span>
<span class="sd">        putting ``c`` on top (compromising), :attr:`w_` at the bottom (burying), while keeping a sincere order on</span>
<span class="sd">        the other candidates.</span>

<span class="sd">        For cardinal voting systems, we call *trivial manipulation* for ``c`` (against :attr:`w_`) the fact of</span>
<span class="sd">        putting the maximum grade for ``c`` and the minimum grade for the other candidates.</span>

<span class="sd">        In both cases, the intuitive idea is the following: if I want to make ``c`` win and I only know that</span>
<span class="sd">        candidate :attr:`w_` is &#39;dangerous&#39; (but I know nothing else), then trivial manipulation is my &#39;best&#39;</span>
<span class="sd">        strategy.</span>

<span class="sd">        We say that a situation is *trivially manipulable* for ``c`` (implicitly: coalitionally) iff, when all voters</span>
<span class="sd">        preferring ``c`` to the sincere winner :attr:`w_` use trivial manipulation, candidate ``c`` wins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.is_tm_c_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_tm_c_">[docs]</a>    <span class="k">def</span> <span class="nf">is_tm_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trivial manipulation, focus on one candidate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or nan</span>
<span class="sd">            ``candidates_tm[c]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">])</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">candidates_tm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans (or ``numpy.nan``). ``candidates_tm[c]`` is ``True`` if a TM for candidate ``c`` is</span>
<span class="sd">        possible, ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan`` (but as of now, this value</span>
<span class="sd">        is not never for TM). For the sincere winner :attr:`w_`, we have by convention ``candidates_tm[w] = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_tm_is_initialized_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize TM variables and perform some preliminary checks. Used only the first time TM is launched</span>
<span class="sd">        (whatever the mode).</span>
<span class="sd">        _is_tm --&gt; True or False if we know, -inf otherwise.</span>
<span class="sd">        _candidates_tm[c] --&gt; True or False if we know, -inf otherwise.</span>

<span class="sd">        If _candidates_tm and _is_tm are totally decided to True, False or NaN, then _tm_was_computed_with_candidates</span>
<span class="sd">        should become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM: Initialize&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tm_is_initialized_general_subclass_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_preliminary_checks_general_</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_tm_is_initialized_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_tm_preliminary_checks_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for TM. Only first time TM is launched.</span>

<span class="sd">        Can update some _candidates_tm[c] to True or False (instead of -inf).</span>

<span class="sd">        * If some ``_candidates_tm[c]`` becomes True, then ``_is_tm`` must become True as well.</span>
<span class="sd">        * If ``_is_tm`` becomes True, it is not necessary to update a specific ``_candidates_tm[c]``.</span>
<span class="sd">        * If for all candidates ``c``, ``_candidates_tm[c]`` become False, then ``_is_tm`` must be updated to False.</span>
<span class="sd">        * If ``_is_tm`` becomes False, then all ``_candidates_tm[c]`` must become False.</span>
<span class="sd">        * If ``_candidates_tm`` and ``_is_tm`` are totally decided to True or False, then</span>
<span class="sd">          ``_tm_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>

<span class="sd">        N.B.: Be careful, if a pretest deciding TM to True is added, then some modifications may be needed for</span>
<span class="sd">        Exhaustive ballot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Preliminary checks that may improve _candidates_tm (all must be done, except if everything is decided).</span>
        <span class="c1"># Majority favorite criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM impossible (w is a majority favorite).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM impossible (w=0 is a majority favorite with candidate tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM impossible (w is a majority favorite with voter tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM impossible (w=0 is a majority favorite with voter and candidate tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Having supporters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_has_supporters_</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># 2) Additional preliminary checks from the subclass.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_preliminary_checks_general_subclass_</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_has_supporters_</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM impossible (all voters like w best)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># For the moment, this cannot happen, because no voting rule overrides</span>
            <span class="c1"># `_tm_preliminary_checks_general_subclass_` (which does nothing by default).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="c1"># 3) Preliminary checks that gives only global information on _is_tm</span>
        <span class="c1"># (may return as soon as decision is made).</span>
        <span class="c1"># Nothing</span>

    <span class="k">def</span> <span class="nf">_tm_preliminary_checks_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for TM. Only first time TM is launched.</span>

<span class="sd">        Can update some ``_candidates_tm[c]`` to True or False (instead of -inf).</span>

<span class="sd">        True must be propagated from specific to general, False must be propagated from general to specific.</span>
<span class="sd">        * If some ``_candidates_tm[c]`` becomes True, then ``_is_tm`` must become True as well.</span>
<span class="sd">        * If ``_is_tm`` becomes True, it is not necessary to update a specific ``_candidates_tm[c]``.</span>
<span class="sd">        * If ``_is_tm`` becomes False, then all ``_candidates_tm[c]`` must become False.</span>
<span class="sd">        * If for all candidates ``c``, ``_candidates_tm[c]`` becomes False, it is not necessary to update ``_is_tm``.</span>
<span class="sd">        * If ``_candidates_tm`` and ``_is_tm`` are totally decided to True or False, then</span>
<span class="sd">          ``_tm_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>

<span class="sd">        Put first the checks that may improve ``_candidates_tm`` (all must be done, except if everything is decided).</span>
<span class="sd">        Then the checks that gives only global information on ``_is_tm`` (which may return as soon as decision is made).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_tm_initialize_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the TM loop for candidate ``c`` and may do preliminary checks.</span>

<span class="sd">        * If ``_candidates_tm[c]`` is decided (True/False/NaN), it means that all the work for ``c`` has been done</span>
<span class="sd">          before. Then get out.</span>
<span class="sd">        * Preliminary checks: try to decide ``_candidates_tm[c]``. If it becomes True, then ``_is_tm`` must become True</span>
<span class="sd">          as well. In other cases, do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Candidate =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Check if job is done for c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;TM: Job already done&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Preliminary checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_preliminary_checks_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># Conclude what we can</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># For the moment, this cannot happen, because no voting rule overrides</span>
            <span class="c1"># `_tm_preliminary_checks_general_subclass_` (which does nothing by default).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Preliminary checks: TM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">equal_false</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># For the moment, this cannot happen, because no voting rule overrides</span>
            <span class="c1"># `_tm_preliminary_checks_general_subclass_` (which does nothing by default).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Preliminary checks: TM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Preliminary checks: TM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tm_preliminary_checks_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;TM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to decide ``_candidates_tm[c]`` to True or False (instead of -inf). Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We not do run any preliminary test for the moment, since computing TM is generally very easy (by design).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tm_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;TM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to decide ``_candidates_tm[c]`` to True or False (instead of -inf). Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_tm_main_work_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Do the main work in TM loop for candidate ``c``. Must decide ``_candidates_tm[c]`` (to True, False or NaN).</span>
<span class="sd">        Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># N.B.: in some subclasses, it is possible to try one method, then another one if the first one fails,</span>
        <span class="c1"># etc. In this general class, we will simply do a switch between &#39;lazy&#39; and &#39;exact&#39;.</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_tm_main_work_c_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm_option</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># Launch a sub-method like _tm_main_work_c_lazy, etc.</span>

    <span class="k">def</span> <span class="nf">_tm_main_work_c_lazy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in TM loop for candidate ``c``, with option &#39;lazy&#39;. Must decide ``_candidates_tm[c]`` (to</span>
<span class="sd">        True, False or NaN). Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">neginf_to_nan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_tm_main_work_c_exact_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in TM loop for candidate ``c``, with option &#39;exact&#39;. Must decide ``_candidates_tm[c]`` (to</span>
<span class="sd">        True, False or NaN). Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_main_work_c_exact_rankings_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_ut_minus1_1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
            <span class="c1"># have other ways to compute TM, so they do not use this.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tm_main_work_c_exact_utilities_minus1_1_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_tm_main_work_c_exact_rankings_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in TM loop for candidate ``c``, with option &#39;exact&#39;, for a voting system based only on</span>
<span class="sd">        strict rankings. Must decide ``_candidates_tm[c]`` (to True, False or NaN). Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Manipulators put c on top and w at bottom.</span>
        <span class="n">w_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">profile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_trivial_strategy_ordinal_</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">.</span><span class="n">w_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: w_test =&quot;</span><span class="p">,</span> <span class="n">w_test</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_test</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tm_main_work_c_exact_utilities_minus1_1_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in TM loop for candidate ``c``, with option &#39;exact&#39;, for a voting system based only on</span>
<span class="sd">        utilities and where it is optimal for a ``c``-manipulator to pretend that ``c`` has utility 1 and other</span>
<span class="sd">        candidates utility 0. Must decide ``_candidates_tm[c]`` (to True, False or NaN). Do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
        <span class="c1"># have other ways to compute TM, so they do not use this.</span>
        <span class="c1">#</span>
        <span class="c1"># Manipulators give -1 to all candidates, except 1 for c.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
        <span class="n">preferences_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_ut</span><span class="p">)</span>
        <span class="n">preferences_test</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">preferences_test</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">w_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">profile</span><span class="o">=</span><span class="n">Profile</span><span class="p">(</span><span class="n">preferences_ut</span><span class="o">=</span><span class="n">preferences_test</span><span class="p">))</span><span class="o">.</span><span class="n">w_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_test</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tm_conclude_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conclude the TM loop for candidate ``c``, according to the value of ``_candidates_tm[c]``.</span>

<span class="sd">        ``_is_tm``:</span>

<span class="sd">        * If ``_candidates_tm[c]`` is True, then ``_is_tm = True``.</span>
<span class="sd">        * Otherwise, do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Final answer: TM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">equal_false</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Final answer: TM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;TM: Final answer: TM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_tm_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_candidates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute TM: is_tm.</span>

<span class="sd">        Note that this method is launched by TM only if _is_tm is not decided, and by tm_with_candidates only if not</span>
<span class="sd">        ``_tm_was_computed_with_candidates``. So, it is not necessary to do a preliminary check on these variables.</span>

<span class="sd">        If ``with_candidates`` is False:</span>
<span class="sd">        * At the end, ``_is_tm`` must be decided to True, False or NaN.</span>
<span class="sd">        * ``_candidates_tm`` must be at least initialized (to an array of -inf). It can be partially decided to True,</span>
<span class="sd">          False or NaN (to avoid some computations if we come back later), but it is not mandatory.</span>
<span class="sd">        * Consistence is not mandatory: notably, if ``_is_tm`` is decided to True, it is not necessary to update a</span>
<span class="sd">          specific ``_candidates_tm[c]``.</span>
<span class="sd">        * If ``_is_tm`` and ``_candidates_tm`` are totally decided to True, False or NaN, then</span>
<span class="sd">          ``_tm_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>

<span class="sd">        If ``with_candidates`` is True:</span>
<span class="sd">        * ``_is_tm`` and ``_candidates_tm`` must be decided to True, False or NaN.</span>
<span class="sd">        * ``_tm_was_computed_with_candidates`` must become True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We start with _is_tm = -Inf (undecided).</span>
        <span class="c1"># If we find a candidate for which _candidates_tm[c] = NaN, then _is_tm becomes NaN too (&quot;at least maybe&quot;).</span>
        <span class="c1"># If we find a candidate for which _candidates_tm[c] = True, then _is_tm becomes True (&quot;surely yes&quot;).</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losing_candidates_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">with_candidates</span> <span class="ow">and</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># If we reach this point, we have decided all _candidates_tm to True, False or NaN.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># even if with_candidates = False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span> <span class="o">=</span> <span class="n">neginf_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_tm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_tm_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute TM for candidate c.</span>

<span class="sd">        Note that this method checks if ``_candidates_tm[c]`` is already decided. So, it is not necessary to do this</span>
<span class="sd">        check before calling the method.</span>

<span class="sd">        During this method:</span>

<span class="sd">        * ``_candidates_tm[c]`` must be decided to True, False or NaN.</span>
<span class="sd">        * If it becomes True, then ``_is_tm`` must become True as well. Otherwise, do not update ``_is_tm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_initialize_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_tm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_main_work_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tm_conclude_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_trivial_strategy_ordinal_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute trivial strategy for an voting system based on strict rankings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            The candidate for whom we want to manipulate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Profile</span>
<span class="sd">            For each voter preferring ``c`` to ``w``, she now puts ``c`` on top, ``w`` at the bottom, and other</span>
<span class="sd">            Borda scores are modified accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preferences_rk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_rk</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogm</span><span class="p">(</span><span class="s2">&quot;Rankings (sincere) =&quot;</span><span class="p">,</span> <span class="n">preferences_rk</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">preferences_rk_manipulators</span> <span class="o">=</span> <span class="n">preferences_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">sorting_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">preferences_rk_manipulators</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">preferences_rk_manipulators</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_array</span><span class="p">)</span>
        <span class="n">preferences_rk_manipulators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">preferences_rk_manipulators</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">preferences_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">preferences_rk_manipulators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogm</span><span class="p">(</span><span class="s2">&quot;Rankings (with trivial strategy) =&quot;</span><span class="p">,</span> <span class="n">preferences_rk</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Profile</span><span class="p">(</span><span class="n">preferences_rk</span><span class="o">=</span><span class="n">preferences_rk</span><span class="p">,</span> <span class="n">sort_voters</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># %% Unison Manipulation (UM)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">log_um_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Parameters used to compute :meth:`is_um_` and related methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;um_option = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">um_option</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_um_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean (or ``numpy.nan``). ``True`` if UM is possible, ``False`` otherwise. If the algorithm cannot decide,</span>
<span class="sd">        then ``numpy.nan``.</span>

<span class="sd">        We say that a situation is *unison-manipulable* for a candidate ``c`` ``!=`` :attr:`w_`  iff all voters who</span>
<span class="sd">        prefer ``c`` to the sincere winner :attr:`w_` can cast the **same** ballot so that ``c`` is elected (while</span>
<span class="sd">        other voters still vote sincerely).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_um_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.is_um_c_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_um_c_">[docs]</a>    <span class="k">def</span> <span class="nf">is_um_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unison manipulation, focus on one candidate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or nan</span>
<span class="sd">            ``candidates_um[c]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_um_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">])</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">candidates_um_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans (or ``numpy.nan``). ``candidates_um_[c]`` is ``True`` if UM for candidate ``c`` is</span>
<span class="sd">        possible, ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan``. For the sincere winner</span>
<span class="sd">        :attr:`w_`, we have by convention ``candidates_um_[w_] = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_um_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_um_is_initialized_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize UM variables and do preliminary checks. Used only the first time UM is launched (whatever the</span>
<span class="sd">        mode).</span>
<span class="sd">        _is_um --&gt; True or False if we know, -inf otherwise.</span>
<span class="sd">        _candidates_um[c] --&gt; True or False if we know, -inf otherwise.</span>

<span class="sd">        If ``_candidates_um`` and ``_is_um`` are totally decided to True, False or NaN, then</span>
<span class="sd">        ``_um_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM: Initialize&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_um_is_initialized_general_subclass_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_preliminary_checks_general_</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_um_is_initialized_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_um_preliminary_checks_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for UM. Only first time UM is launched.</span>

<span class="sd">        Can update some ``_candidates_um[c]`` to True or False (instead of -inf).</span>

<span class="sd">        * If some ``_candidates_um[c]`` becomes True, then ``_is_um`` must become True as well.</span>
<span class="sd">        * If ``_is_um`` becomes True, it is not necessary to update a specific ``_candidates_um[c].``</span>
<span class="sd">        * If for all candidates ``c``, ``_candidates_um[c]`` become False, then ``_is_um`` must be updated to False.</span>
<span class="sd">        * If ``_is_um`` becomes False, then all ``_candidates_um[c]`` must become False.</span>
<span class="sd">        * If ``_candidates_um`` and ``_is_um`` are totally decided to True or False, then</span>
<span class="sd">          ``_um_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Preliminary checks that may improve ``_candidates_um`` (all must be done, except if everything is decided).</span>
        <span class="c1"># Majority favorite criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM impossible (w is a majority favorite).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM impossible (w=0 is a majority favorite with candidate tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM impossible (w is a majority favorite with voter tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM impossible (w=0 is a majority favorite with voter and candidate tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Condorcet resistance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_resistant_condorcet_winner_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM impossible (w is a Resistant Condorcet winner)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Having supporters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_has_supporters_</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># 2) Additional preliminary checks from the subclass.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_preliminary_checks_general_subclass_</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM: preliminary checks: UM is impossible.&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="c1"># 3) Preliminary checks that gives only global information on _is_um (may return as soon as decision is made).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_admissible_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM found (w is not Condorcet-admissible)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_um_preliminary_checks_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for UM. Only first time UM is launched.</span>

<span class="sd">        Can update some ``_candidates_um[c]`` to True or False (instead of -inf). True must be propagated from</span>
<span class="sd">        specific to general, False must be propagated from general to specific.</span>

<span class="sd">        * If some ``_candidates_um[c]`` becomes True, then ``_is_um`` must become True as well.</span>
<span class="sd">        * If ``_is_um`` becomes True, it is not necessary to update a specific ``_candidates_um[c]``.</span>
<span class="sd">        * If ``_is_um`` becomes False, then all ``_candidates_um[c]`` must become False.</span>
<span class="sd">        * If for all candidates ``c``, ``_candidates_um[c]`` becomes False, it is not necessary to update ``_is_um``.</span>
<span class="sd">        * If ``_candidates_um`` and ``_is_um`` are totally decided to True or False, then</span>
<span class="sd">          ``_um_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>

<span class="sd">        Put first the checks that may improve ``_candidates_um`` (all must be done, except if everything is decided).</span>
<span class="sd">        Then the checks that gives only global information on ``_is_um`` (which may return as soon as decision is made).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_um_initialize_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the UM loop for candidate ``c`` and may do preliminary checks.</span>

<span class="sd">        * If ``_candidates_um[c]`` is decided (True/False/NaN), it means that all the work for ``c`` has been done</span>
<span class="sd">          before. Then get out.</span>
<span class="sd">        * Preliminary checks: try to decide ``_candidates_um[c]``. If it becomes True, then ``_is_um`` must become True</span>
<span class="sd">          as well. In other cases, do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Candidate =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Check if job is done for c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;UM: Job already done&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Preliminary checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_preliminary_checks_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># Conclude what we can</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Preliminary checks: UM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">equal_false</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Preliminary checks: UM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Preliminary checks: UM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_um_preliminary_checks_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;UM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to decide _candidates_um[c]`` to True or False (instead of -inf). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>  <span class="c1"># Number of manipulators</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">-</span> <span class="n">n_m</span>                    <span class="c1"># Number of sincere voters</span>
        <span class="c1"># Positive pretest based on the majority favorite criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: n_m &gt; n_v / 2&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: n_m &gt;= n_v / 2 and c == 0&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Negative pretest based on the majority favorite criterion</span>
        <span class="c1"># If ``plurality_scores_ut[w] &gt; (n_s + n_m) / 2``, then CM impossible.</span>
        <span class="c1"># Necessary condition: ``n_m &gt;= 2 * plurality_scores_ut[w] - n_s``.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: even with n_m manipulators, w stays plurality winner (ut)&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: even with n_m manipulators, w stays plurality winner (ut, ctb)&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: even with n_m manipulators, w stays plurality winner (rk)&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: even with n_m manipulators, w stays plurality winner (rk, ctb)&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
        <span class="c1"># Pretest based on the same idea as Condorcet resistance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">threshold_c_prevents_w_condorcet_ut_abs</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s1">&#39;UM: Preliminary checks: c-manipulators cannot prevent w from being a Condorcet winner&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
        <span class="c1"># Other pretests</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_um_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;UM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to decide ``_candidates_um[c]`` to True or False (instead of -inf). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_um_main_work_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Do the main work in UM loop for candidate ``c``. Must decide ``_candidates_um[c]`` (to True,</span>
<span class="sd">        False or NaN). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># N.B.: in some subclasses, it is possible to try one method, then another one if the first one fails,</span>
        <span class="c1"># etc. In this general class, we will simply do a switch between &#39;lazy&#39; and &#39;exact&#39;.</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_um_main_work_c_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">um_option</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># Launch a sub-method like _um_main_work_c_lazy, etc.</span>

    <span class="k">def</span> <span class="nf">_um_main_work_c_lazy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in UM loop for candidate c, with option &#39;lazy&#39;. Must decide ``_candidates_um[c]`` (to True,</span>
<span class="sd">        False or NaN). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">neginf_to_nan</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_um_main_work_c_exact_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in UM loop for candidate ``c``, with option &#39;exact&#39;. Must decide ``_candidates_um[c]`` (to</span>
<span class="sd">        True, False or NaN). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_main_work_c_exact_rankings_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_ut_minus1_1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
            <span class="c1"># have other ways to compute UM, so they do not use this.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_um_main_work_c_exact_utilities_minus1_1_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_um_main_work_c_exact_rankings_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in UM loop for candidate ``c``, with option &#39;exact&#39;, for a voting system based only on</span>
<span class="sd">        strict rankings. Must decide ``_candidates_um[c]`` (to True, False or NaN). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preferences_rk_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_rk</span><span class="p">)</span>
        <span class="n">base_ballot</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="p">])</span>  <span class="c1"># Put c first for the first try...</span>
        <span class="k">for</span> <span class="n">ballot</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">base_ballot</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Ballot =&quot;</span><span class="p">,</span> <span class="n">ballot</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">preferences_rk_test</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ballot</span>
            <span class="n">w_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span>
                <span class="n">profile</span><span class="o">=</span><span class="n">Profile</span><span class="p">(</span><span class="n">preferences_rk</span><span class="o">=</span><span class="n">preferences_rk_test</span><span class="p">,</span> <span class="n">sort_voters</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">w_</span>
            <span class="k">if</span> <span class="n">w_test</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_um_main_work_c_exact_utilities_minus1_1_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in UM loop for candidate ``c``, with option &#39;exact&#39;, for a voting system based only on</span>
<span class="sd">        utilities and where it is optimal for a c-manipulator to pretend that ``c`` has utility 1 and other</span>
<span class="sd">        candidates utility 0. Must decide ``_candidates_um[c]`` (to True, False or NaN). Do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
        <span class="c1"># have other ways to compute UM, so they do not use this.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_um_conclude_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conclude the UM loop for candidate ``c``, according to the value of ``_candidates_um[c]``.</span>
<span class="sd">        ``_is_um`` --&gt;</span>
<span class="sd">            * If ``_candidates_um[c]`` is True, then ``_is_um = True``.</span>
<span class="sd">            * Otherwise, do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Final answer: UM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">equal_false</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Final answer: UM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;UM: Final answer: UM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_um_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_candidates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute UM: ``is_um``.</span>

<span class="sd">        Note that this method is launched by ``is_um_`` only if ``_is_um`` is not decided, and by ``candidates_um_``</span>
<span class="sd">        only if not ``_um_was_computed_with_candidates``. So, it is not necessary to do a preliminary check on these</span>
<span class="sd">        variables.</span>

<span class="sd">        If ``with_candidates`` is False:</span>

<span class="sd">        * At the end, ``_is_um`` must be decided to True, False or NaN.</span>
<span class="sd">        * ``_candidates_um`` must be at least initialized (to an array of -inf). It can be partially decided to True,</span>
<span class="sd">          False or NaN (to avoid some computations if we come back later), but it is not mandatory.</span>
<span class="sd">        * Consistence is not mandatory: notably, if ``_is_um`` is decided to True, it is not necessary to update a</span>
<span class="sd">          specific ``_candidates_um[c]``.</span>
<span class="sd">        * If ``_is_um`` and ``_candidates_um`` are totally decided to True, False or NaN, then</span>
<span class="sd">          ``_um_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>

<span class="sd">        If ``with_candidates`` is True:</span>

<span class="sd">        * ``_is_um`` and ``_candidates_um`` must be decided to True, False or NaN.</span>
<span class="sd">        * ``_um_was_computed_with_candidates`` must become True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We start with ``_is_um = -Inf`` (undecided).</span>
        <span class="c1"># If we find a candidate for which ``_candidates_um[c] = NaN``, then ``_is_um`` becomes NaN too (&quot;at least</span>
        <span class="c1">#   maybe&quot;).</span>
        <span class="c1"># If we find a candidate for which ``_candidates_um[c] = True``, then ``_is_um`` becomes True (&quot;surely yes&quot;).</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losing_candidates_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_um_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">with_candidates</span> <span class="ow">and</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># If we reach this point, we have decided all _candidates_um to True, False or NaN.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># even if with_candidates = False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span> <span class="o">=</span> <span class="n">neginf_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_um</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_um_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute UM for candidate ``c``.</span>

<span class="sd">        Note that this method checks if ``_candidates_um[c]`` is already decided. So, it is not necessary to do this</span>
<span class="sd">        check before calling the method.</span>

<span class="sd">        During this method:</span>

<span class="sd">        * ``_candidates_um[c]`` must be decided to True, False or NaN.</span>
<span class="sd">        * If it becomes True, then ``_is_um`` must become True as well. Otherwise, do not update ``_is_um``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_initialize_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_um</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_main_work_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_um_conclude_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="c1"># %% Ignorant-Coalition Manipulation (ICM)</span>
    <span class="c1"># When the voting systems meets IgnMC with ctb, it is very easy, and it is managed at the beginning of</span>
    <span class="c1"># ``_compute_icm``. So, for most subroutines, we can suppose that the voting system does not meet IgnMC with ctb.</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">log_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Parameters used to compute :meth:`is_icm_` and related methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;icm_option = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">icm_option</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean (or ``numpy.nan``). ``True`` if an ICM is possible, ``False`` otherwise. If the algorithm cannot</span>
<span class="sd">        decide, then ``numpy.nan``.</span>

<span class="sd">        We say that a situation is *Ignorant-Coalition Manipulable* (ICM) for ``c`` ``!=`` :attr:`w_` iff the voters</span>
<span class="sd">        who prefer ``c`` to :attr:`w_` can cast ballots so that, whatever the other voters do, ``c`` is elected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_icm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.is_icm_c_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_icm_c_">[docs]</a>    <span class="k">def</span> <span class="nf">is_icm_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ignorant-Coalition Manipulation, focus on one candidate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or nan</span>
<span class="sd">            ``candidates_icm[c]_``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_icm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">])</span></div>

<div class="viewcode-block" id="Rule.is_icm_c_with_bounds_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_icm_c_with_bounds_">[docs]</a>    <span class="k">def</span> <span class="nf">is_icm_c_with_bounds_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ignorant-Coalition Manipulation, focus on one candidate, with bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (``candidates_icm_[c]``, ``necessary_coalition_size_icm_[c]``, ``sufficient_coalition_size_icm_[c]``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_icm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">candidates_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans (or ``numpy.nan``). ``candidates_icm_[c]`` is ``True`` if ICM for candidate ``c`` is</span>
<span class="sd">        possible, ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan``. For the sincere winner</span>
<span class="sd">        :attr:`w_`, we have by convention ``candidates_icm[w_] = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_with_candidates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_icm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_coalition_sizes_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_full</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_icm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;necessary_coalition_size_icm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                <span class="s1">&#39;sufficient_coalition_size_icm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)}</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">necessary_coalition_size_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of integers. ``necessary_coalition_size_icm[c]`` is the lower bound found by the algorithm for</span>
<span class="sd">        :math:`x_c` (see below). For the sincere winner :attr:`w_`, we have by convention</span>
<span class="sd">        ``necessary_coalition_size_icm_[w_] = 0``.</span>

<span class="sd">        Internally, to decide the problem of ICM, SVVAMP studies the following question. When considering the</span>
<span class="sd">        sub-population of voters who do not prefer ``c`` to :attr:`w_` (sincere voters), what is the minimal number</span>
<span class="sd">        :math:`x_c` of ``c``-manipulators needed to perform ICM? For all voting system currently implemented in</span>
<span class="sd">        SVVAMP, it means that ICM is possible iff there are :math:`x_c` voters or more who prefer ``c`` to :attr:`w_`.</span>

<span class="sd">        For information only, the result of SVVAMP&#39;s computations about :math:`x_c` is given in outputs</span>
<span class="sd">        ``necessary_coalition_size_icm_`` and ``sufficient_coalition_size_icm_``. By definition, we have</span>
<span class="sd">        ``necessary_coalition_size_icm_[c]`` :math:`\leq x_c \leq` ``sufficient_coalition_size_icm_[c]``.</span>

<span class="sd">        When :attr:`icm_option` = ``&#39;exact&#39;``, the exactness concerns the ICM decision problems (boolean results below),</span>
<span class="sd">        but not the numerical evaluation of :math:`x_c`. It means that for all boolean answers, SVVAMP will not answer</span>
<span class="sd">        ``numpy.nan`` ( undecided). But it is possible that ``necessary_coalition_size_icm_[c]`` &lt;</span>
<span class="sd">        ``sufficient_coalition_size_icm_[c]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coalition_sizes_icm_</span><span class="p">[</span><span class="s1">&#39;necessary_coalition_size_icm&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">sufficient_coalition_size_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d of integers or ``numpy.inf``. ``sufficient_coalition_size_icm[c]`` is the upper bound found by the</span>
<span class="sd">        algorithm for :math:`x_c` (see :meth:`necessary_coalition_size_icm_`). For the sincere winner :attr:`w_`,</span>
<span class="sd">        we have by convention ``sufficient_coalition_size_icm_[w_] = 0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coalition_sizes_icm_</span><span class="p">[</span><span class="s1">&#39;sufficient_coalition_size_icm&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_icm_is_initialized_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize ICM variables an do preliminary checks. Used each time ICM is launched (whatever the mode).</span>
<span class="sd">        ``_is_icm`` --&gt; False or True if we know, -inf otherwise.</span>
<span class="sd">        ``_candidates_icm[c]`` --&gt; True or False if we know, -inf otherwise.</span>

<span class="sd">        ``_sufficient_coalition_size_icm[c]`` --&gt; +inf (except for w).</span>
<span class="sd">        ``_necessary_coalition_size_icm`` --&gt; 0.</span>
<span class="sd">        ``_bounds_optimized_icm[c]`` --&gt; False.</span>
<span class="sd">        For ``_sufficient_coalition_size_icm`` and ``_necessary_coalition_size_icm``, it is not recommended to do better</span>
<span class="sd">        here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM: Initialize&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_full</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_is_initialized_general_subclass_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_preliminary_checks_general_</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_icm_is_initialized_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_icm_preliminary_checks_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for ICM. Only first time ICM is launched.</span>

<span class="sd">        Can update some ``_candidates_icm[c]`` to True or False (instead of -inf).</span>

<span class="sd">        * If some ``_candidates_icm[c]`` becomes True, then ``_is_icm`` must become True as well.</span>
<span class="sd">        * If ``_is_icm`` becomes True, it is not necessary to update a specific ``_candidates_icm[c]``.</span>
<span class="sd">        * If for all candidates ``c``, ``_candidates_icm[c]`` become False, then ``_is_icm`` must be updated to False.</span>
<span class="sd">        * If ``_is_icm`` becomes False, then all ``_candidates_icm[c]`` must become False.</span>
<span class="sd">        * If ``_candidates_icm`` and ``_is_icm`` are totally decided to True or False, then</span>
<span class="sd">          ``_icm_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_ut_abs_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM impossible (w is a Condorcet winner)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_has_supporters_</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM: preliminary checks: ICM is impossible.&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_admissible_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM found (w is not Condorcet-admissible)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Other checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_preliminary_checks_general_subclass_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_icm_preliminary_checks_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for ICM. Only first time ICM is launched.</span>

<span class="sd">        Can update ``_is_icm`` to True or False (instead of -inf).</span>

<span class="sd">        * If ``_is_icm`` becomes True, it is not necessary to update a specific ``_candidates_icm[c]``.</span>
<span class="sd">        * If ``_is_icm`` becomes False, then all ``_candidates_icm[c]`` must become False. And it is recommended that</span>
<span class="sd">          ``_icm_was_computed_with_candidates`` becomes True.</span>

<span class="sd">        For ``_sufficient_coalition_size_icm`` and ``_necessary_coalition_size_icm``, it is not recommended to do</span>
<span class="sd">        better here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_icm_initialize_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the ICM loop for candidate ``c`` and do preliminary checks.</span>

<span class="sd">        * If ``_bounds_optimized_icm[c]`` is True, it means that all the work for ``c`` has been done before. Then get</span>
<span class="sd">          out.</span>
<span class="sd">        * If ``_candidates_icm[c]`` is decided (True/False/NaN) and ``optimize_bounds`` is False, then get out.</span>
<span class="sd">        * Preliminary checks to improve bounds ``_sufficient_coalition_size_icm[c]`` and</span>
<span class="sd">          ``_necessary_coalition_size_icm[c]``.</span>
<span class="sd">        * If the two bounds are equal, then ``_bounds_optimized_icm[c]`` becomes True.</span>
<span class="sd">        * Update ``_candidates_icm[c]`` to True or False if possible.</span>
<span class="sd">        * If we can decide ``_is_icm`` to True, do it.</span>

<span class="sd">        :return: Boolean, ``job_done``. True iff we have done all the job for ``c`` (with bounds if ``optimize_bounds``</span>
<span class="sd">        is True, only for ``_candidates_icm[c]`` otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Candidate =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Check if job is done for c</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM: Job already done&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="n">optimize_bounds</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM: Job already done&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Improve bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_preliminary_checks_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="c1"># Conclude what we can</span>
        <span class="c1"># Some log</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: necessary_coalition_size_icm[c] =&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: sufficient_coalition_size_icm[c] =&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: n_m =&quot;</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Conclude</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: Bounds are equal&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: ICM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="n">optimize_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: ICM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="n">optimize_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Preliminary checks: ICM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_icm_preliminary_checks_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ICM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to improve bounds ``_sufficient_coalition_size_icm[c]`` and ``_necessary_coalition_size_icm[c]``. Do not</span>
<span class="sd">        update the other variables.</span>

<span class="sd">        If ``optimize_bounds`` is False, then return as soon as ``n_m &gt;= _sufficient_coalition_size_icm[c]``, or</span>
<span class="sd">        ``_necessary_coalition_size_icm[c] &gt; n_m`` (where ``n_m`` is the number or manipulators).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>  <span class="c1"># Number of manipulators</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">-</span> <span class="n">n_m</span>  <span class="c1"># Number of sincere voters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c_ctb</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="s1">&#39;ICM: InfMC_c_ctb =&gt; necessary_coalition_size_icm[c] = n_s + 1 =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_s</span><span class="p">,</span>
                                   <span class="s1">&#39;ICM: InfMC_c =&gt; necessary_coalition_size_icm[c] = n_s =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c_ctb</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_s</span><span class="p">,</span>
                                    <span class="s1">&#39;ICM: IgnMC_c =&gt; sufficient_coalition_size_icm[c] = n_s =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="s1">&#39;ICM: IgnMC_c =&gt; sufficient_coalition_size_icm[c] = n_s + 1 =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span>
        <span class="c1"># Other preliminary checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_icm_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ICM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to improve bounds ``_sufficient_coalition_size_icm[c]`` and ``_necessary_coalition_size_icm[c]``. Do not</span>
<span class="sd">        update the other variables.</span>

<span class="sd">        If ``optimize_bounds`` is False, then return as soon as ``n_m &gt;= _sufficient_coalition_size_icm[c]``, or</span>
<span class="sd">        ``_necessary_coalition_size_icm[c] &gt; n_m`` (where ``n_m`` is the number or manipulators).</span>

<span class="sd">        If a test is especially costly, it is recommended to test first if ``_sufficient_coalition_size_icm[c] ==</span>
<span class="sd">        _necessary_coalition_size_icm[c]`` and to return immediately in that case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_icm_main_work_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in ICM loop for candidate ``c``.</span>

<span class="sd">        * Try to improve bounds ``_sufficient_coalition_size_icm[c]`` and ``_necessary_coalition_size_icm[c]``.</span>
<span class="sd">        * Do not update other variables (``_is_icm``, ``_candidates_icm``, etc.).</span>

<span class="sd">        If ``optimize_bounds`` is False, can return as soon as ``n_m &gt;= _sufficient_coalition_size_icm[c]``, or</span>
<span class="sd">        ``_necessary_coalition_size_icm[c] &gt; n_m`` (where ``n_m`` is the number or manipulators).</span>

<span class="sd">        :return: Boolean, ``is_quick_escape``. True if we did not improve the bound the best we could. (Allowed to be</span>
<span class="sd">            None or False otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># N.B.: in some subclasses, it is possible to try one method, then another one if the first one fails,</span>
        <span class="c1"># etc. In this general class, we will simply do a switch between &#39;lazy&#39; and &#39;exact&#39;.</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_icm_main_work_c_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">icm_option</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="c1"># Launch a sub-method like _icm_main_work_c_lazy_, etc.</span>

    <span class="c1"># noinspection PyMethodMayBeStatic,PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">_icm_main_work_c_lazy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in ICM loop for candidate ``c``, with option &#39;lazy&#39;. Same specifications as</span>
<span class="sd">        ``_icm_main_work_c_``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># With option &#39;lazy&#39;, there is nothing to do! And this is not a &#39;quick escape&#39;: we did the best we could</span>
        <span class="c1"># (considering laziness). N.B.: for most voting system, lazy is actually quite good for ICM! In fact,</span>
        <span class="c1"># as soon as _meets_IgnMC_c_ctb, this lazy method is exact!</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># noinspection PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">_icm_main_work_c_exact_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in ICM loop for candidate ``c``, with option &#39;exact&#39;. Same specifications as</span>
<span class="sd">        ``_icm_main_work_c``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c_ctb</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_icm_conclude_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">is_quick_escape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conclude the ICM loop for candidate ``c``.</span>
<span class="sd">        ``_bounds_optimized_icm[c]`` --&gt; if not ``quick_escape``, becomes True.</span>
<span class="sd">        ``_candidates_icm[c]`` --&gt; True, False or NaN according to the bounds ``_sufficient_coalition_size_icm[c]`` and</span>
<span class="sd">            ``_necessary_coalition_size_icm[c]``.</span>
<span class="sd">        ``_is_icm`` --&gt;</span>
<span class="sd">            * If ``_candidates_icm[c]`` is True, then ``_is_icm`` = True.</span>
<span class="sd">            * Otherwise, do not update ``_is_icm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_quick_escape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Final answer: ICM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Final answer: ICM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;ICM: Final answer: ICM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">_compute_icm_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_candidates</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute ICM.</span>

<span class="sd">        Note that this method is launched by ``is_icm_`` only if ICM was not initialized, and by ``candidates_icm_``</span>
<span class="sd">        only if not ``_icm_was_computed_with_candidates``. So, it is not necessary to do a preliminary check on these</span>
<span class="sd">        variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;Compute ICM&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># We start with ``_is_icm`` = -Inf (undecided).</span>
        <span class="c1"># If we find a candidate for which ``_candidates_icm[c] = NaN``, then ``_is_icm`` becomes NaN too (&quot;at least</span>
        <span class="c1">#   maybe&quot;).</span>
        <span class="c1"># If we find a candidate for which ``_candidates_icm[c] = True``, then ``_is_icm`` becomes True (&quot;surely yes&quot;).</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losing_candidates_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_icm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">with_candidates</span> <span class="ow">and</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># If we reach this point, we have decided all ``_candidates_icm`` to True, False or NaN.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span> <span class="o">=</span> <span class="n">neginf_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_icm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optimize_bounds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_icm_was_computed_full</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_compute_icm_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="n">job_done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_initialize_c</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">job_done</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_icm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">is_quick_escape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_icm_main_work_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_icm_conclude_c</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">is_quick_escape</span><span class="p">)</span>

    <span class="c1"># %% Coalition Manipulation (CM)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">log_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String. Parameters used to compute :meth:`is_cm_` and related methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_option</span> <span class="o">==</span> <span class="s1">&#39;exact&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;cm_option = exact&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;cm_option = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_option</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">precheck_um</span> <span class="o">*</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_um_</span><span class="p">)</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">precheck_icm</span> <span class="o">*</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_icm_</span><span class="p">)</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">precheck_tm</span> <span class="o">*</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_tm_</span><span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean (or ``numpy.nan``). ``True`` if a CM is possible, ``False`` otherwise. If the algorithm cannot</span>
<span class="sd">        decide, then ``numpy.nan``.</span>

<span class="sd">        We say that a situation is *Coalitionally Manipulable* (CM) for ``c`` ``!=`` :attr:`w_` iff voters who prefer</span>
<span class="sd">        ``c`` to :attr:`w_` can cast ballots so that ``c`` is elected (while other voters still vote sincerely).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span><span class="p">)</span>

<div class="viewcode-block" id="Rule.is_cm_c_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_cm_c_">[docs]</a>    <span class="k">def</span> <span class="nf">is_cm_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coalition Manipulation, focus on one candidate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or nan</span>
<span class="sd">            ``candidates_cm[c]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">])</span></div>

<div class="viewcode-block" id="Rule.is_cm_c_with_bounds_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.is_cm_c_with_bounds_">[docs]</a>    <span class="k">def</span> <span class="nf">is_cm_c_with_bounds_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coalition Manipulation, focus on one candidate, with bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : int</span>
<span class="sd">            Candidate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (``candidates_cm[c]``, ``necessary_coalition_size_cm[c]``, ``sufficient_coalition_size_cm[c]``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_is_initialized_general_</span>
        <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pseudo_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">candidates_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of booleans (or ``numpy.nan``). ``candidates_cm_[c]`` is ``True`` if CM for candidate ``c`` is</span>
<span class="sd">        possible, ``False`` otherwise. If the algorithm cannot decide, then ``numpy.nan``. For the sincere winner</span>
<span class="sd">        :attr:`w_`, we have by convention ``candidates_cm_[w_] = False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_coalition_sizes_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_is_initialized_general_</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_full</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cm_</span><span class="p">(</span><span class="n">with_candidates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;necessary_coalition_size_cm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                <span class="s1">&#39;sufficient_coalition_size_cm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)}</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">necessary_coalition_size_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of integers. ``necessary_coalition_size_cm_[c]`` is the lower bound found by the algorithm for</span>
<span class="sd">        :math:`x_c` (cf. below). For the sincere winner :attr:`w_`, we have by convention</span>
<span class="sd">        ``necessary_coalition_size_cm_[w_] = 0``.</span>

<span class="sd">        Internally, to decide the problem of CM, SVVAMP studies the following question. When considering the</span>
<span class="sd">        sub-population of voters who do not prefer ``c`` to :attr:`w_` (sincere voters), what is the minimal number</span>
<span class="sd">        :math:`x_c` of ``c``-manipulators needed to perform CM? For all voting system currently implemented in SVVAMP,</span>
<span class="sd">        it means that CM is possible iff there are :math:`x_c` voters or more who prefer ``c`` to :attr:`w_`. (A</span>
<span class="sd">        sufficient condition on the voting system is that, if a population elects ``c``, then an additional voter may</span>
<span class="sd">        always cast a ballot so that ``c`` stays elected)</span>

<span class="sd">        For information only, the result of SVVAMP&#39;s computations about :math:`x_c` is given in outputs</span>
<span class="sd">        ``necessary_coalition_size_cm_`` and ``sufficient_coalition_size_cm_``. By definition, we have</span>
<span class="sd">        ``necessary_coalition_size_cm_[c]`` :math:`\leq x_c \leq` ``sufficient_coalition_size_cm_[c]``.</span>

<span class="sd">        When :attr:`cm_option` = ``&#39;exact&#39;``, the exactness concerns the CM decision problems (Boolean results), not</span>
<span class="sd">        the numerical evaluation of :math:`x_c`. It means that for all Boolean answers, SVVAMP will not answer</span>
<span class="sd">        ``numpy.nan`` ( undecided). But it is possible that ``necessary_coalition_size_cm_[c]`` &lt;</span>
<span class="sd">        ``sufficient_coalition_size_cm_[c]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coalition_sizes_cm_</span><span class="p">[</span><span class="s1">&#39;necessary_coalition_size_cm&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">sufficient_coalition_size_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;1d array of integers or ``numpy.inf``. ``sufficient_coalition_size_cm_[c]`` is the upper bound found by the</span>
<span class="sd">        algorithm for :math:`x_c` (cf. :attr:`necessary_coalition_size_cm_`). For the sincere winner :attr:`w_`, we</span>
<span class="sd">        have by convention ``sufficient_coalition_size_cm_[w_] = 0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coalition_sizes_cm_</span><span class="p">[</span><span class="s1">&#39;sufficient_coalition_size_cm&#39;</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_cm_is_initialized_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize CM variables and do preliminary checks. Used only the first time CM is launched (whatever the</span>
<span class="sd">        mode).</span>
<span class="sd">        ``_is_cm`` --&gt; False or True if we know, -inf otherwise.</span>
<span class="sd">        ``_candidates_cm[c]`` --&gt; True or False if we know, -inf otherwise.</span>

<span class="sd">        ``_sufficient_coalition_size_cm[c]`` --&gt; +inf (except for ``w_``).</span>
<span class="sd">        ``_necessary_coalition_size_cm[c]`` --&gt; 0.</span>
<span class="sd">        ``_bounds_optimized_cm[c]`` --&gt; False.</span>
<span class="sd">        For ``_sufficient_coalition_size_cm`` and ``_necessary_coalition_size_cm``, it is not recommended to do</span>
<span class="sd">        better here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM: Initialize&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_full</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_is_initialized_general_subclass_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_preliminary_checks_general_</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_cm_is_initialized_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_cm_preliminary_checks_general_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for CM. Only first time CM is launched.</span>

<span class="sd">        Can update some ``_candidates_cm[c]`` to True or False (instead of -inf).</span>

<span class="sd">        * If some ``_candidates_cm[c]`` becomes True, then ``_is_cm`` must become True as well.</span>
<span class="sd">        * If ``_is_cm`` becomes True, it is not necessary to update a specific ``_candidates_cm[c]``.</span>
<span class="sd">        * If for all candidates ``c``, ``_candidates_cm[c]`` becomes False, then ``_is_cm`` must be updated to False.</span>
<span class="sd">        * If ``_is_cm`` becomes False, then all ``_candidates_cm[c]`` must become False.</span>
<span class="sd">        * If ``_candidates_cm`` and ``_is_cm`` are totally decided to True or False, then</span>
<span class="sd">        ``_cm_was_computed_with_candidates`` should become True (not mandatory but recommended).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) Preliminary checks that may improve _candidates_cm (all must be done, except if everything is decided).</span>
        <span class="c1"># Majority favorite criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM impossible (w is a majority favorite).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM impossible (w=0 is a majority favorite with candidate tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM impossible (w is a majority favorite with voter tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM impossible (w=0 is a majority favorite with voter and candidate tie-breaking).&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Condorcet resistance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_resistant_condorcet_winner_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM impossible (w is a Resistant Condorcet winner)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># Having supporters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_has_supporters_</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM: preliminary checks: CM is impossible.&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># 2) Preliminary checks that gives only global information on _is_cm (may return as soon as decision is made).</span>
        <span class="c1"># InfMC</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_not_condorcet_admissible_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM found (w is not Condorcet-admissible)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="c1"># ICM</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_icm</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_icm_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM found (thanks to ICM)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
        <span class="c1"># TM</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_tm</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tm_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM found (thanks to TM)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
        <span class="c1"># UM</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_um</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_um_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM found (thanks to UM)&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
        <span class="c1"># 3) Other checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_preliminary_checks_general_subclass_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_cm_preliminary_checks_general_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do preliminary checks for CM. Only first time CM is launched.</span>

<span class="sd">        Can update ``_is_cm`` to True or False (instead of -inf).</span>

<span class="sd">        * If ``_is_cm`` becomes True, it is not necessary to update a specific ``_candidates_cm[c]``.</span>
<span class="sd">        * If ``_is_cm`` becomes False, then all ``_candidates_cm[c]`` must become False. And it is recommended that</span>
<span class="sd">        ``_cm_was_computed_with_candidates`` becomes True.</span>

<span class="sd">        For ``_sufficient_coalition_size_cm`` and ``_necessary_coalition_size_cm``, it is not recommended to do</span>
<span class="sd">        better here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_cm_initialize_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the CM loop for candidate ``c`` and do preliminary checks.</span>

<span class="sd">        * If ``_bounds_optimized_cm[c]`` is True, it means that all the work for ``c`` has been done before. Then get</span>
<span class="sd">          out.</span>
<span class="sd">        * If ``_candidates_cm[c]`` is decided (True/False/NaN) and ``optimize_bounds`` is False, then get out.</span>
<span class="sd">        * Preliminary checks to improve bounds ``_sufficient_coalition_size_cm[c]`` and</span>
<span class="sd">          ``_necessary_coalition_size_cm[c]``.</span>
<span class="sd">        * If the two bounds are equal, then ``_bounds_optimized_cm[c]`` becomes True.</span>
<span class="sd">        * Update ``_candidates_cm[c]`` to True or False if possible.</span>
<span class="sd">        * If we can decide ``_is_cm`` to True, do it.</span>

<span class="sd">        :return: Boolean, ``job_done``. True iff we have done all the job for ``c`` (with bounds if ``optimize_bounds``</span>
<span class="sd">        is True, only for ``_candidates_cm[c]`` otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Candidate =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Check  if job is done for c</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM: Job already done&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="n">optimize_bounds</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM: Job already done&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Improve bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_preliminary_checks_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="c1"># Conclude what we can</span>
        <span class="c1"># Some log</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: necessary_coalition_size_cm[c] =&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: sufficient_coalition_size_cm[c] =&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: n_m =&quot;</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Conclude</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylog</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: Bounds are equal&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: CM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="n">optimize_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: CM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">equal_false</span><span class="p">(</span><span class="n">optimize_bounds</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Preliminary checks: CM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_cm_preliminary_checks_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;CM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to improve bounds ``_sufficient_coalition_size_cm[c]`` and ``_necessary_coalition_size_cm[c]``. Do not</span>
<span class="sd">        update the other variables.</span>

<span class="sd">        If ``optimize_bounds`` is False, then return as soon as ``n_m &gt;= _sufficient_coalition_size_cm[c]``,</span>
<span class="sd">        or ``_necessary_coalition_size_cm[c] &gt; n_m`` (where ``n_m`` is the number or manipulators).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>  <span class="c1"># Number of manipulators</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span> <span class="o">-</span> <span class="n">n_m</span>  <span class="c1"># Number of sincere voters</span>
        <span class="c1"># Pretest based on Informed Majority Coalition Criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c_ctb</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_s</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: InfMC_c_ctb =&gt; </span><span class="se">\n</span><span class="s1">    sufficient_coalition_size_cm[c] = n_s =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: InfMC_c =&gt; </span><span class="se">\n</span><span class="s1">    sufficient_coalition_size_cm[c] = n_s + 1 =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span>
        <span class="c1"># Pretest based on the majority favorite criterion</span>
        <span class="c1"># If ``plurality_scores_ut[w] &gt; (n_s + n_m) / 2``, then CM impossible.</span>
        <span class="c1"># Necessary condition: ``n_m &gt;= 2 * plurality_scores_ut[w_] - n_s``.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: majority_favorite_c_rk_ctb =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                <span class="s1">&#39;necessary_coalition_size_cm[c] = 2 * plurality_scores_rk[w] - n_s + 1 =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_rk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: majority_favorite_c_rk =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                <span class="s1">&#39;necessary_coalition_size_cm[c] = 2 * plurality_scores_rk[w] - n_s =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: majority_favorite_c_ut_ctb =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                <span class="s1">&#39;necessary_coalition_size_cm[c] = 2 * plurality_scores_ut[w] - n_s + 1 =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">plurality_scores_ut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_s</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: majority_favorite_c_ut =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                <span class="s1">&#39;necessary_coalition_size_cm[c] = 2 * plurality_scores_ut[w] - n_s =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="k">return</span>
        <span class="c1"># Pretest based on the same idea as Condorcet resistance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">threshold_c_prevents_w_condorcet_ut_abs</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">],</span>
                <span class="s1">&#39;CM: Preliminary checks: Condorcet_c =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                <span class="s1">&#39;necessary_coalition_size_cm[c] = threshold_c_prevents_w_Condorcet_ut_abs[c, w] =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_m</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="c1"># Pretests based on ICM, TM and UM</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_icm</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">suf_icm_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_icm_c_with_bounds_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">suf_icm_c</span><span class="p">,</span>
                <span class="s1">&#39;CM: Preliminary checks: ICM =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                <span class="s1">&#39;sufficient_coalition_size_cm[c] = sufficient_coalition_size_icm[c] =&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_tm</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span>
                    <span class="s1">&#39;CM: Preliminary checks: TM =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                    <span class="s1">&#39;sufficient_coalition_size_cm[c] = n_m =&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span><span class="p">:</span>
                    <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precheck_um</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span>
                    <span class="s1">&#39;CM: Preliminary checks: UM =&gt; </span><span class="se">\n</span><span class="s1">    &#39;</span>
                    <span class="s1">&#39;sufficient_coalition_size_cm[c] = n_m =&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span><span class="p">:</span>
                    <span class="k">return</span>
        <span class="c1"># Other preliminary checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cm_preliminary_checks_c_subclass_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;CM: preliminary checks for challenger ``c``.</span>

<span class="sd">        Try to improve bounds ``_sufficient_coalition_size_cm[c]`` and ``_necessary_coalition_size_cm[c]``. Do not</span>
<span class="sd">        update the other variables.</span>

<span class="sd">        If ``optimize_bounds`` is False, then return as soon as ``n_m &gt;= _sufficient_coalition_size_cm[c]``,</span>
<span class="sd">        or ``_necessary_coalition_size_cm[c] &gt; n_m`` (where ``n_m`` is the number or manipulators).</span>

<span class="sd">        If a test is especially costly, it is recommended to test first if ``_sufficient_coalition_size_cm[c] ==</span>
<span class="sd">        _necessary_coalition_size_cm[c]`` and to return immediately in that case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_cm_main_work_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in CM loop for candidate ``c``.</span>

<span class="sd">        * Try to improve bounds ``_sufficient_coalition_size_cm[c]`` and ``_necessary_coalition_size_cm[c]``.</span>
<span class="sd">        * Do not update other variables (``_is_cm``, ``_candidates_cm``, etc.).</span>

<span class="sd">        If ``optimize_bounds`` is False, can return as soon as ``n_m &gt;= _sufficient_coalition_size_cm[c]``, or</span>
<span class="sd">        ``_necessary_coalition_size_cm[c] &gt; n_m`` (where ``n_m`` is the number or manipulators).</span>

<span class="sd">        :return: Boolean, ``is_quick_escape``. True if we did not improve the bound the best we could. (Allowed to be</span>
<span class="sd">            None or False otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># N.B.: in some subclasses, it is possible to try one method, then another one if the first one fails,</span>
        <span class="c1"># etc. In this general class, we will simply do a switch between &#39;lazy&#39; and &#39;exact&#39;.</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cm_main_work_c_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_option</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="c1"># Launch a sub-method like _cm_main_work_v_lazy_, etc.</span>

    <span class="c1"># noinspection PyUnusedLocal,PyMethodMayBeStatic</span>
    <span class="k">def</span> <span class="nf">_cm_main_work_c_lazy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in CM loop for candidate ``c``, with option &#39;lazy&#39;. Same specifications as</span>
<span class="sd">        :meth:`_cm_main_work_c_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># With option &#39;lazy&#39;, there is nothing to do! And this is not a &#39;quick escape&#39;: we did the best we could</span>
        <span class="c1"># (considering laziness).</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># noinspection PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">_cm_main_work_c_exact_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the main work in CM loop for candidate ``c``, with option &#39;exact&#39;. Same specifications as</span>
<span class="sd">        ``_cm_main_work_c``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_ut_minus1_1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># As of now, all the voting rules concerned (Majority Judgement, Range Voting and Approval)</span>
            <span class="c1"># have other ways to compute TM, so they do not use this.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="c1"># TM was already checked during preliminary checks. If TM was not True, then CM impossible.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="c1"># This exhaustive algorithm will not do better (so, this is not a quick escape).</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="c1"># Idem.</span>
            <span class="k">return</span>
        <span class="n">preferences_borda_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">),</span> <span class="p">(</span><span class="n">n_m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_borda_rk</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]),</span> <span class="p">:],</span>
        <span class="p">))</span>
        <span class="n">manipulator_favorite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">preferences_borda_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># self.mylogm(&#39;preferences_borda_temp =&#39;, preferences_borda_temp, 3)</span>
            <span class="n">w_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">profile</span><span class="o">=</span><span class="n">Profile</span><span class="p">(</span><span class="n">preferences_ut</span><span class="o">=</span><span class="n">preferences_borda_temp</span><span class="p">))</span><span class="o">.</span><span class="n">w_</span>
            <span class="k">if</span> <span class="n">w_test</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_sufficient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_m</span><span class="p">,</span>
                                        <span class="s1">&#39;CM: Manipulation found by exhaustive test =&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                        <span class="s1">&#39;    sufficient_coalition_size_cm = n_m =&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">i_manipulator</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">new_ballot</span><span class="p">,</span> <span class="n">new_favorite</span> <span class="o">=</span> <span class="n">compute_next_borda_clever</span><span class="p">(</span>
                    <span class="n">preferences_borda_temp</span><span class="p">[</span><span class="n">i_manipulator</span><span class="p">,</span> <span class="p">:],</span> <span class="n">manipulator_favorite</span><span class="p">[</span><span class="n">i_manipulator</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
                <span class="c1"># self.mylogv(&#39;new_ballot = &#39;, new_ballot)</span>
                <span class="k">if</span> <span class="n">new_ballot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">preferences_borda_temp</span><span class="p">[</span><span class="n">i_manipulator</span><span class="p">:</span><span class="n">n_m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_ballot</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">manipulator_favorite</span><span class="p">[</span><span class="n">i_manipulator</span><span class="p">:</span><span class="n">n_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_favorite</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preferences_borda_temp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_necessary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="s1">&#39;CM: Manipulation proven impossible by exhaustive test =&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
                                   <span class="s1">&#39;    necessary_coalition_size_cm[c] = n_m + 1 =&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cm_conclude_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">is_quick_escape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conclude the CM loop for candidate ``c``.</span>

<span class="sd">        ``_bounds_optimized_cm[c]`` --&gt; if not ``quick_escape``, becomes True.</span>
<span class="sd">        ``_candidates_cm[c]`` --&gt; True, False or NaN according to the bounds ``_sufficient_coalition_size_cm[c]`` and</span>
<span class="sd">            ``_necessary_coalition_size_cm[c]``.</span>
<span class="sd">        ``_is_cm`` --&gt;</span>
<span class="sd">            * If ``_candidates_cm[c]`` is True, then ``_is_cm = True``.</span>
<span class="sd">            * Otherwise, do not update ``_is_cm``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_quick_escape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_optimized_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">n_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">matrix_duels_ut</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sufficient_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Final answer: CM is True for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">n_m</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_coalition_size_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Final answer: CM is False for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mylogv</span><span class="p">(</span><span class="s2">&quot;CM: Final answer: CM is unknown for c =&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">_compute_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_candidates</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute CM.</span>

<span class="sd">        Note that this method is launched by ``is_cm_`` only if CM was not initialized, and by ``candidates_cm_``</span>
<span class="sd">        only if not ``_cm_was_computed_with_candidates``. So, it is not necessary to do a preliminary check on these</span>
<span class="sd">        variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We start with ``_is_cm = -Inf`` (undecided).</span>
        <span class="c1"># If we find a candidate for which ``_candidates_cm[c] = NaN``, then ``_is_cm`` becomes NaN too (&quot;at least</span>
        <span class="c1">#   maybe&quot;).</span>
        <span class="c1"># If we find a candidate for which ``_candidates_cm[c] = True``, then ``_is_cm`` becomes True (&quot;surely yes&quot;).</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losing_candidates_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_cm_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">with_candidates</span> <span class="ow">and</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># If we reach this point, we have decided all ``_candidates_cm`` to True, False or NaN.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_with_candidates</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># even if ``with_candidates = False``</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span> <span class="o">=</span> <span class="n">neginf_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_cm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optimize_bounds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cm_was_computed_full</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_compute_cm_c_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">):</span>
        <span class="n">job_done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_initialize_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">job_done</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_bounds</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_candidates_cm</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># TO DO: Investigate whether this case can actually happen.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">is_quick_escape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cm_main_work_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">optimize_bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cm_conclude_c_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">is_quick_escape</span><span class="p">)</span>

    <span class="c1"># %% Indicators with manipulation</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">elects_condorcet_winner_rk_even_with_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;bool : True iff there is a Condorcet winner, she is elected by sincere voting and it is not CM.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">exists_condorcet_winner_rk</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_is_condorcet_winner_rk_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pseudo_bool_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_cm_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">nb_candidates_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of candidates who can benefit from CM.&quot;&quot;&quot;</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">candidates_cm_</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sup</span> <span class="o">=</span> <span class="n">inf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">candidates_cm_</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">inf</span><span class="p">,</span> <span class="n">sup</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">worst_relative_welfare_with_cm_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Worst relative social welfare (sincere winner or candidate who can benefit from CM).&quot;&quot;&quot;</span>
        <span class="n">possible_winners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_cm_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">possible_winners</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">relative_social_welfare_c</span><span class="p">[(</span><span class="n">possible_winners</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">possible_winners</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">sup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">relative_social_welfare_c</span><span class="p">[</span><span class="n">possible_winners</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">inf</span><span class="p">,</span> <span class="n">sup</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">cm_power_index_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;CM power index. For each candidate c != w, it is n_s / x_c (where n_s is the number of sincere voters</span>
<span class="sd">        and `x_c` the minimal number of manipulators that can make `c` win (cf :attr:`necessary_coalition_size_cm_`).</span>
<span class="sd">        Globally, it is the max over the candidates c != w.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_sincere_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">n_sincere_c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sufficient_coalition_size_cm_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_coalition_size_cm_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sufficient_coalition_size_cm_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">necessary_coalition_size_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">necessary_coalition_size_cm_</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">necessary_coalition_size_cm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">n_sincere_c</span><span class="p">[</span><span class="n">necessary_coalition_size_cm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                <span class="o">/</span> <span class="n">necessary_coalition_size_cm</span><span class="p">[</span><span class="n">necessary_coalition_size_cm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">n_sincere_c</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">necessary_coalition_size_cm_</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">return</span> <span class="n">inf</span><span class="p">,</span> <span class="n">sup</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">is_tm_or_um_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tm_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">equal_true</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_um_</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tm_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_um_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># %% Demo</span>

<div class="viewcode-block" id="Rule.demo_manipulation_"><a class="viewcode-back" href="../../../reference/rules/rule.html#svvamp.Rule.demo_manipulation_">[docs]</a>    <span class="k">def</span> <span class="nf">demo_manipulation_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Demonstrate the manipulation methods of :class:`Rule` class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_depth : int</span>
<span class="sd">            Integer from 0 (basic info) to 3 (verbose).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_log_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_depth</span> <span class="o">=</span> <span class="n">log_depth</span>

        <span class="n">print_big_title</span><span class="p">(</span><span class="s2">&quot;Election Manipulation&quot;</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Basic properties of the voting system&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with_two_candidates_reduces_to_plurality = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_two_candidates_reduces_to_plurality</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_based_on_rk = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_rk</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_based_on_ut_minus1_1 = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_based_on_ut_minus1_1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;meets_iia = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meets_iia</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Manipulation properties of the voting system&quot;</span><span class="p">)</span>

        <span class="c1"># Condorcet_c_ut_rel_ctb (False)     ==&gt;     Condorcet_c_ut_rel (False)</span>
        <span class="c1">#  ||                                                               ||</span>
        <span class="c1">#  ||     Condorcet_c_rk_ctb (False) ==&gt; Condorcet_c_rk (False)     ||</span>
        <span class="c1">#  ||           ||               ||       ||             ||         ||</span>
        <span class="c1">#  V            V                ||       ||             V          V</span>
        <span class="c1"># Condorcet_c_ut_abs_ctb (False)     ==&gt;     Condorcet_ut_abs_c (False)</span>
        <span class="c1">#  ||                            ||       ||                        ||</span>
        <span class="c1">#  ||                            V        V                         ||</span>
        <span class="c1">#  ||       maj_fav_c_rk_ctb (False) ==&gt; maj_fav_c_rk (False)       ||</span>
        <span class="c1">#  ||           ||                                       ||         ||</span>
        <span class="c1">#  V            V                                        V          V</span>
        <span class="c1"># majority_favorite_c_ut_ctb (False) ==&gt; majority_favorite_c_ut (False)</span>
        <span class="c1">#  ||                                                               ||</span>
        <span class="c1">#  V                                                                V</span>
        <span class="c1"># IgnMC_c_ctb (False)                ==&gt;                IgnMC_c (False)</span>
        <span class="c1">#  ||                                                               ||</span>
        <span class="c1">#  V                                                                V</span>
        <span class="c1"># InfMC_c_ctb (False)                ==&gt;                InfMC_c (False)</span>

        <span class="k">def</span> <span class="nf">display_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;(True) &#39;</span> <span class="k">if</span> <span class="n">equal_true</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;(False)&#39;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Condorcet_c_ut_rel_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39;     ==&gt;     Condorcet_c_ut_rel &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_rel</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||                                                               ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||     Condorcet_c_rk_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39; ==&gt; Condorcet_c_rk &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_rk</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;     ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||           ||               ||       ||             ||         ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; V            V                ||       ||             V          V&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Condorcet_c_ut_abs_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39;     ==&gt;     Condorcet_ut_abs_c &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_condorcet_c_ut_abs</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||                            ||       ||                        ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||                            V        V                         ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||       maj_fav_c_rk_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39; ==&gt; maj_fav_c_rk &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_rk</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;       ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||           ||                                       ||         ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; V            V                                        V          V&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;majority_favorite_c_ut_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39; ==&gt; majority_favorite_c_ut &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_majority_favorite_c_ut</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||                                                               ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; V                                                                V&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;IgnMC_c_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39;                ==&gt;                IgnMC_c &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_ignmc_c</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; ||                                                               ||&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; V                                                                V&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;InfMC_c_ctb &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c_ctb</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39;                ==&gt;                InfMC_c &#39;</span> <span class="o">+</span> <span class="n">display_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meets_infmc_c</span><span class="p">))</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Independence of Irrelevant Alternatives (IIA)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_iia =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_iia_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_iia:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_iia_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;example_winner_iia =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">example_winner_iia_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;example_subset_iia =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">example_subset_iia_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;c-Manipulators&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;preferences_ut (reminder) =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">preferences_ut</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;v_wants_to_help_c = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_wants_to_help_c_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Individual Manipulation (IM)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_im =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_im_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_im:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_im_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;candidates_im =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_im_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Trivial Manipulation (TM)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_tm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tm_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_tm:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_tm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;candidates_tm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_tm_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Unison Manipulation (UM)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_um =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_um_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_um:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_um_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;candidates_um =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_um_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s2">&quot;Ignorant-Coalition Manipulation (ICM)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_icm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_icm_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_icm:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_icm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;candidates_icm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_icm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;necessary_coalition_size_icm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">necessary_coalition_size_icm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;sufficient_coalition_size_icm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_coalition_size_icm_</span><span class="p">)</span>

        <span class="n">print_title</span><span class="p">(</span><span class="s1">&#39;Coalition Manipulation (CM)&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_cm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cm_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_cm:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_cm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;candidates_cm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">candidates_cm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;necessary_coalition_size_cm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">necessary_coalition_size_cm_</span><span class="p">)</span>
        <span class="n">printm</span><span class="p">(</span><span class="s2">&quot;sufficient_coalition_size_cm =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sufficient_coalition_size_cm_</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_depth</span> <span class="o">=</span> <span class="n">old_log_depth</span></div>

    <span class="k">def</span> <span class="nf">_reached_uncovered_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a log message when some uncovered code is reached.</span>

<span class="sd">        We should call this method each time a portion of code is not covered by the tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">inspect</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="n">calling_frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getouterframes</span><span class="p">(</span><span class="n">current_frame</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">caller_name</span> <span class="o">=</span> <span class="n">calling_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You reached a portion of code that is not covered by the tests. If you want to </span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="s2">&quot;help SVVAMP&#39;s developers, please send an email to fradurand@gmail.com and </span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="s2">&quot;copy-paste the following log message.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">caller_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_v =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_v</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_c =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">n_c</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_</span><span class="o">.</span><span class="n">to_doctest_string</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result_options =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_options</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_iia_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_im_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_tm_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_um_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_icm_</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_cm_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">OPTIONS</span><span class="o">.</span><span class="n">ERROR_WHEN_UNCOVERED_CODE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Uncovered portion of code.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_example_reached_uncovered_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Demonstrate :meth:`_reached_uncovered_code` (cf. the unit test in `test_rule.py`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reached_uncovered_code</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_random_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set random options.</span>

<span class="sd">        For each option where a set of values is allowed, select a random value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">option</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;allowed&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;allowed&#39;</span><span class="p">])</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_random_instruction</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Random instruction (used for testing purposes, especially identify uncovered code).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A random instruction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;is_im_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_c_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_c_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_c_with_voters_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_c_with_voters_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;voters_im_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;candidates_im_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;v_im_for_c_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_v_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_v_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_v_with_candidates_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_im_v_with_candidates_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_tm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_tm_c_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_tm_c_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;candidates_tm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_um_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_um_c_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_um_c_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;candidates_um_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_icm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_icm_c_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_icm_c_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_icm_c_with_bounds_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_icm_c_with_bounds_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;candidates_icm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;necessary_coalition_size_icm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;sufficient_coalition_size_icm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_cm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_cm_c_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_cm_c_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_cm_c_with_bounds_(0)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_cm_c_with_bounds_(1)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;candidates_cm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;necessary_coalition_size_cm_&#39;</span><span class="p">,</span>
            <span class="s1">&#39;sufficient_coalition_size_cm_&#39;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Fran√ßois Durand.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>